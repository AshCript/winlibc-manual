.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Cairo 3pm"
.TH Cairo 3pm "2022-10-20" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cairo \- Perl interface to the cairo 2d vector graphics library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Cairo;
\&
\&  my $surface = Cairo::ImageSurface\->create (\*(Aqargb32\*(Aq, 100, 100);
\&  my $cr = Cairo::Context\->create ($surface);
\&
\&  $cr\->rectangle (10, 10, 40, 40);
\&  $cr\->set_source_rgb (0, 0, 0);
\&  $cr\->fill;
\&
\&  $cr\->rectangle (50, 50, 40, 40);
\&  $cr\->set_source_rgb (1, 1, 1);
\&  $cr\->fill;
\&
\&  $cr\->show_page;
\&
\&  $surface\->write_to_png (\*(Aqoutput.png\*(Aq);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Cairo provides Perl bindings for the vector graphics library cairo.  It
supports multiple output targets, including \s-1PNG, PDF\s0 and \s-1SVG.\s0  Cairo produces
identical output on all those targets.
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
This is a listing of the \s-1API\s0 Cairo provides.  For more verbose information,
refer to the cairo manual at <http://cairographics.org/manual/>.
.SS "Drawing"
.IX Subsection "Drawing"
\fICairo::Context \*(-- The cairo drawing context\fR
.IX Subsection "Cairo::Context The cairo drawing context"
.PP
\&\fICairo::Context\fR is the main object used when drawing with Cairo. To draw with
Cairo, you create a \fICairo::Context\fR, set the target surface, and drawing
options for the \fICairo::Context\fR, create shapes with methods like
\&\f(CW\*(C`$cr\->move_to\*(C'\fR and \f(CW\*(C`$cr\->line_to\*(C'\fR, and then draw shapes with
\&\f(CW\*(C`$cr\->stroke\*(C'\fR or \f(CW\*(C`$cr\->fill\*(C'\fR.
.PP
\&\fICairo::Context\fR's can be pushed to a stack via \f(CW\*(C`$cr\->save\*(C'\fR. They may
then safely be changed, without loosing the current state. Use
\&\f(CW\*(C`$cr\->restore\*(C'\fR to restore to the saved state.
.ie n .IP "$cr = Cairo::Context\->create ($surface)" 4
.el .IP "\f(CW$cr\fR = Cairo::Context\->create ($surface)" 4
.IX Item "$cr = Cairo::Context->create ($surface)"
.RS 4
.PD 0
.ie n .IP "$surface: \fICairo::Surface\fR" 4
.el .IP "\f(CW$surface:\fR \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.RE
.RS 4
.RE
.ie n .IP "$cr\->save" 4
.el .IP "\f(CW$cr\fR\->save" 4
.IX Item "$cr->save"
.ie n .IP "$cr\->restore" 4
.el .IP "\f(CW$cr\fR\->restore" 4
.IX Item "$cr->restore"
.ie n .IP "$status = $cr\->status" 4
.el .IP "\f(CW$status\fR = \f(CW$cr\fR\->status" 4
.IX Item "$status = $cr->status"
.ie n .IP "$surface = $cr\->get_target" 4
.el .IP "\f(CW$surface\fR = \f(CW$cr\fR\->get_target" 4
.IX Item "$surface = $cr->get_target"
.ie n .IP "$cr\->push_group [1.2]" 4
.el .IP "\f(CW$cr\fR\->push_group [1.2]" 4
.IX Item "$cr->push_group [1.2]"
.ie n .IP "$cr\->push_group_with_content ($content) [1.2]" 4
.el .IP "\f(CW$cr\fR\->push_group_with_content ($content) [1.2]" 4
.IX Item "$cr->push_group_with_content ($content) [1.2]"
.RS 4
.ie n .IP "$content: \fICairo::Content\fR" 4
.el .IP "\f(CW$content:\fR \fICairo::Content\fR" 4
.IX Item "$content: Cairo::Content"
.RE
.RS 4
.RE
.ie n .IP "$pattern = $cr\->pop_group [1.2]" 4
.el .IP "\f(CW$pattern\fR = \f(CW$cr\fR\->pop_group [1.2]" 4
.IX Item "$pattern = $cr->pop_group [1.2]"
.ie n .IP "$cr\->pop_group_to_source [1.2]" 4
.el .IP "\f(CW$cr\fR\->pop_group_to_source [1.2]" 4
.IX Item "$cr->pop_group_to_source [1.2]"
.ie n .IP "$surface = $cr\->get_group_target [1.2]" 4
.el .IP "\f(CW$surface\fR = \f(CW$cr\fR\->get_group_target [1.2]" 4
.IX Item "$surface = $cr->get_group_target [1.2]"
.ie n .IP "$cr\->set_source_rgb ($red, $green, $blue)" 4
.el .IP "\f(CW$cr\fR\->set_source_rgb ($red, \f(CW$green\fR, \f(CW$blue\fR)" 4
.IX Item "$cr->set_source_rgb ($red, $green, $blue)"
.RS 4
.ie n .IP "$red: double" 4
.el .IP "\f(CW$red:\fR double" 4
.IX Item "$red: double"
.ie n .IP "$green: double" 4
.el .IP "\f(CW$green:\fR double" 4
.IX Item "$green: double"
.ie n .IP "$blue: double" 4
.el .IP "\f(CW$blue:\fR double" 4
.IX Item "$blue: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_source_rgba ($red, $green, $blue, $alpha)" 4
.el .IP "\f(CW$cr\fR\->set_source_rgba ($red, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR)" 4
.IX Item "$cr->set_source_rgba ($red, $green, $blue, $alpha)"
.RS 4
.ie n .IP "$red: double" 4
.el .IP "\f(CW$red:\fR double" 4
.IX Item "$red: double"
.ie n .IP "$green: double" 4
.el .IP "\f(CW$green:\fR double" 4
.IX Item "$green: double"
.ie n .IP "$blue: double" 4
.el .IP "\f(CW$blue:\fR double" 4
.IX Item "$blue: double"
.ie n .IP "$alpha: double" 4
.el .IP "\f(CW$alpha:\fR double" 4
.IX Item "$alpha: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_source ($source)" 4
.el .IP "\f(CW$cr\fR\->set_source ($source)" 4
.IX Item "$cr->set_source ($source)"
.RS 4
.ie n .IP "$source: \fICairo::Pattern\fR" 4
.el .IP "\f(CW$source:\fR \fICairo::Pattern\fR" 4
.IX Item "$source: Cairo::Pattern"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_source_surface ($surface, $x, $y)" 4
.el .IP "\f(CW$cr\fR\->set_source_surface ($surface, \f(CW$x\fR, \f(CW$y\fR)" 4
.IX Item "$cr->set_source_surface ($surface, $x, $y)"
.RS 4
.ie n .IP "$surface: \fICairo::Surface\fR" 4
.el .IP "\f(CW$surface:\fR \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "$source = $cr\->get_source" 4
.el .IP "\f(CW$source\fR = \f(CW$cr\fR\->get_source" 4
.IX Item "$source = $cr->get_source"
.ie n .IP "$cr\->set_antialias ($antialias)" 4
.el .IP "\f(CW$cr\fR\->set_antialias ($antialias)" 4
.IX Item "$cr->set_antialias ($antialias)"
.RS 4
.ie n .IP "$antialias: \fICairo::Antialias\fR" 4
.el .IP "\f(CW$antialias:\fR \fICairo::Antialias\fR" 4
.IX Item "$antialias: Cairo::Antialias"
.RE
.RS 4
.RE
.ie n .IP "$antialias = $cr\->get_antialias" 4
.el .IP "\f(CW$antialias\fR = \f(CW$cr\fR\->get_antialias" 4
.IX Item "$antialias = $cr->get_antialias"
.ie n .IP "$cr\->set_dash ($offset, ...)" 4
.el .IP "\f(CW$cr\fR\->set_dash ($offset, ...)" 4
.IX Item "$cr->set_dash ($offset, ...)"
.RS 4
.ie n .IP "$offset: double" 4
.el .IP "\f(CW$offset:\fR double" 4
.IX Item "$offset: double"
.IP "...: list of doubles" 4
.IX Item "...: list of doubles"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_fill_rule ($fill_rule)" 4
.el .IP "\f(CW$cr\fR\->set_fill_rule ($fill_rule)" 4
.IX Item "$cr->set_fill_rule ($fill_rule)"
.RS 4
.ie n .IP "$fill_rule: \fICairo::FillRule\fR" 4
.el .IP "\f(CW$fill_rule:\fR \fICairo::FillRule\fR" 4
.IX Item "$fill_rule: Cairo::FillRule"
.RE
.RS 4
.RE
.ie n .IP "$fill_rule = $cr\->get_fill_rule" 4
.el .IP "\f(CW$fill_rule\fR = \f(CW$cr\fR\->get_fill_rule" 4
.IX Item "$fill_rule = $cr->get_fill_rule"
.ie n .IP "$cr\->set_line_cap ($line_cap)" 4
.el .IP "\f(CW$cr\fR\->set_line_cap ($line_cap)" 4
.IX Item "$cr->set_line_cap ($line_cap)"
.RS 4
.ie n .IP "$line_cap: \fICairo::LineCap\fR" 4
.el .IP "\f(CW$line_cap:\fR \fICairo::LineCap\fR" 4
.IX Item "$line_cap: Cairo::LineCap"
.RE
.RS 4
.RE
.ie n .IP "$line_cap = $cr\->get_line_cap" 4
.el .IP "\f(CW$line_cap\fR = \f(CW$cr\fR\->get_line_cap" 4
.IX Item "$line_cap = $cr->get_line_cap"
.ie n .IP "$cr\->set_line_join ($line_join)" 4
.el .IP "\f(CW$cr\fR\->set_line_join ($line_join)" 4
.IX Item "$cr->set_line_join ($line_join)"
.RS 4
.ie n .IP "$line_join: \fICairo::LineJoin\fR" 4
.el .IP "\f(CW$line_join:\fR \fICairo::LineJoin\fR" 4
.IX Item "$line_join: Cairo::LineJoin"
.RE
.RS 4
.RE
.ie n .IP "$line_join = $cr\->get_line_join" 4
.el .IP "\f(CW$line_join\fR = \f(CW$cr\fR\->get_line_join" 4
.IX Item "$line_join = $cr->get_line_join"
.ie n .IP "$cr\->set_line_width ($width)" 4
.el .IP "\f(CW$cr\fR\->set_line_width ($width)" 4
.IX Item "$cr->set_line_width ($width)"
.RS 4
.ie n .IP "$width: double" 4
.el .IP "\f(CW$width:\fR double" 4
.IX Item "$width: double"
.RE
.RS 4
.RE
.ie n .IP "$width = $cr\->get_line_width" 4
.el .IP "\f(CW$width\fR = \f(CW$cr\fR\->get_line_width" 4
.IX Item "$width = $cr->get_line_width"
.ie n .IP "$cr\->set_miter_limit ($limit)" 4
.el .IP "\f(CW$cr\fR\->set_miter_limit ($limit)" 4
.IX Item "$cr->set_miter_limit ($limit)"
.RS 4
.ie n .IP "$limit: double" 4
.el .IP "\f(CW$limit:\fR double" 4
.IX Item "$limit: double"
.RE
.RS 4
.RE
.ie n .IP "($offset, @dashes) = $cr\->get_dash [1.4]" 4
.el .IP "($offset, \f(CW@dashes\fR) = \f(CW$cr\fR\->get_dash [1.4]" 4
.IX Item "($offset, @dashes) = $cr->get_dash [1.4]"
.ie n .IP "$limit = $cr\->get_miter_limit" 4
.el .IP "\f(CW$limit\fR = \f(CW$cr\fR\->get_miter_limit" 4
.IX Item "$limit = $cr->get_miter_limit"
.ie n .IP "$cr\->set_operator ($op)" 4
.el .IP "\f(CW$cr\fR\->set_operator ($op)" 4
.IX Item "$cr->set_operator ($op)"
.RS 4
.ie n .IP "$op: \fICairo::Operator\fR" 4
.el .IP "\f(CW$op:\fR \fICairo::Operator\fR" 4
.IX Item "$op: Cairo::Operator"
.RE
.RS 4
.RE
.ie n .IP "$op = $cr\->get_operator" 4
.el .IP "\f(CW$op\fR = \f(CW$cr\fR\->get_operator" 4
.IX Item "$op = $cr->get_operator"
.ie n .IP "$cr\->set_tolerance ($tolerance)" 4
.el .IP "\f(CW$cr\fR\->set_tolerance ($tolerance)" 4
.IX Item "$cr->set_tolerance ($tolerance)"
.RS 4
.ie n .IP "$tolerance: double" 4
.el .IP "\f(CW$tolerance:\fR double" 4
.IX Item "$tolerance: double"
.RE
.RS 4
.RE
.ie n .IP "$tolerance = $cr\->get_tolerance" 4
.el .IP "\f(CW$tolerance\fR = \f(CW$cr\fR\->get_tolerance" 4
.IX Item "$tolerance = $cr->get_tolerance"
.ie n .IP "$cr\->clip" 4
.el .IP "\f(CW$cr\fR\->clip" 4
.IX Item "$cr->clip"
.ie n .IP "$cr\->clip_preserve" 4
.el .IP "\f(CW$cr\fR\->clip_preserve" 4
.IX Item "$cr->clip_preserve"
.ie n .IP "($x1, $y1, $x2, $y2) = $cr\->clip_extents [1.4]" 4
.el .IP "($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR) = \f(CW$cr\fR\->clip_extents [1.4]" 4
.IX Item "($x1, $y1, $x2, $y2) = $cr->clip_extents [1.4]"
.ie n .IP "$bool = $cr\->in_clip ($x, $y) [1.10]" 4
.el .IP "\f(CW$bool\fR = \f(CW$cr\fR\->in_clip ($x, \f(CW$y\fR) [1.10]" 4
.IX Item "$bool = $cr->in_clip ($x, $y) [1.10]"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "@rectangles = $cr\->copy_clip_rectangle_list [1.4]" 4
.el .IP "\f(CW@rectangles\fR = \f(CW$cr\fR\->copy_clip_rectangle_list [1.4]" 4
.IX Item "@rectangles = $cr->copy_clip_rectangle_list [1.4]"
.ie n .IP "$cr\->reset_clip" 4
.el .IP "\f(CW$cr\fR\->reset_clip" 4
.IX Item "$cr->reset_clip"
.ie n .IP "$cr\->fill" 4
.el .IP "\f(CW$cr\fR\->fill" 4
.IX Item "$cr->fill"
.ie n .IP "$cr\->fill_preserve" 4
.el .IP "\f(CW$cr\fR\->fill_preserve" 4
.IX Item "$cr->fill_preserve"
.ie n .IP "($x1, $y1, $x2, $y2) = $cr\->fill_extents" 4
.el .IP "($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR) = \f(CW$cr\fR\->fill_extents" 4
.IX Item "($x1, $y1, $x2, $y2) = $cr->fill_extents"
.ie n .IP "$bool = $cr\->in_fill ($x, $y)" 4
.el .IP "\f(CW$bool\fR = \f(CW$cr\fR\->in_fill ($x, \f(CW$y\fR)" 4
.IX Item "$bool = $cr->in_fill ($x, $y)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->mask ($pattern)" 4
.el .IP "\f(CW$cr\fR\->mask ($pattern)" 4
.IX Item "$cr->mask ($pattern)"
.RS 4
.ie n .IP "$pattern: \fICairo::Pattern\fR" 4
.el .IP "\f(CW$pattern:\fR \fICairo::Pattern\fR" 4
.IX Item "$pattern: Cairo::Pattern"
.RE
.RS 4
.RE
.ie n .IP "$cr\->mask_surface ($surface, $surface_x, $surface_y)" 4
.el .IP "\f(CW$cr\fR\->mask_surface ($surface, \f(CW$surface_x\fR, \f(CW$surface_y\fR)" 4
.IX Item "$cr->mask_surface ($surface, $surface_x, $surface_y)"
.RS 4
.ie n .IP "$surface: \fICairo::Surface\fR" 4
.el .IP "\f(CW$surface:\fR \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.ie n .IP "$surface_x: double" 4
.el .IP "\f(CW$surface_x:\fR double" 4
.IX Item "$surface_x: double"
.ie n .IP "$surface_y: double" 4
.el .IP "\f(CW$surface_y:\fR double" 4
.IX Item "$surface_y: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->paint" 4
.el .IP "\f(CW$cr\fR\->paint" 4
.IX Item "$cr->paint"
.ie n .IP "$cr\->paint_with_alpha ($alpha)" 4
.el .IP "\f(CW$cr\fR\->paint_with_alpha ($alpha)" 4
.IX Item "$cr->paint_with_alpha ($alpha)"
.RS 4
.ie n .IP "$alpha: double" 4
.el .IP "\f(CW$alpha:\fR double" 4
.IX Item "$alpha: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->stroke" 4
.el .IP "\f(CW$cr\fR\->stroke" 4
.IX Item "$cr->stroke"
.ie n .IP "$cr\->stroke_preserve" 4
.el .IP "\f(CW$cr\fR\->stroke_preserve" 4
.IX Item "$cr->stroke_preserve"
.ie n .IP "($x1, $y1, $x2, $y2) = $cr\->stroke_extents" 4
.el .IP "($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR) = \f(CW$cr\fR\->stroke_extents" 4
.IX Item "($x1, $y1, $x2, $y2) = $cr->stroke_extents"
.ie n .IP "$bool = $cr\->in_stroke ($x, $y)" 4
.el .IP "\f(CW$bool\fR = \f(CW$cr\fR\->in_stroke ($x, \f(CW$y\fR)" 4
.IX Item "$bool = $cr->in_stroke ($x, $y)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->tag_begin($name, $atts) [1.16]" 4
.el .IP "\f(CW$cr\fR\->tag_begin($name, \f(CW$atts\fR) [1.16]" 4
.IX Item "$cr->tag_begin($name, $atts) [1.16]"
.RS 4
.ie n .IP "$name: string" 4
.el .IP "\f(CW$name:\fR string" 4
.IX Item "$name: string"
.ie n .IP "$atts: string" 4
.el .IP "\f(CW$atts:\fR string" 4
.IX Item "$atts: string"
.RE
.RS 4
.RE
.ie n .IP "$cr\->tag_end($name) [1.16]" 4
.el .IP "\f(CW$cr\fR\->tag_end($name) [1.16]" 4
.IX Item "$cr->tag_end($name) [1.16]"
.RS 4
.ie n .IP "$name: string" 4
.el .IP "\f(CW$name:\fR string" 4
.IX Item "$name: string"
.RE
.RS 4
.RE
.IP "Predefined names:" 4
.IX Item "Predefined names:"
.RS 4
.IP "Cairo::TAG_DEST [1.16]" 4
.IX Item "Cairo::TAG_DEST [1.16]"
.IP "Cairo::TAG_LINK [1.16]" 4
.IX Item "Cairo::TAG_LINK [1.16]"
.RE
.RS 4
.RE
.ie n .IP "$cr\->copy_page" 4
.el .IP "\f(CW$cr\fR\->copy_page" 4
.IX Item "$cr->copy_page"
.ie n .IP "$cr\->show_page" 4
.el .IP "\f(CW$cr\fR\->show_page" 4
.IX Item "$cr->show_page"
.PD
.PP
\fIPaths \*(-- Creating paths and manipulating path data\fR
.IX Subsection "Paths Creating paths and manipulating path data"
.PP
.Vb 7
\&  $path = [
\&    { type => "move\-to", points => [[1, 2]] },
\&    { type => "line\-to", points => [[3, 4]] },
\&    { type => "curve\-to", points => [[5, 6], [7, 8], [9, 10]] },
\&    ...
\&    { type => "close\-path", points => [] },
\&  ];
.Ve
.PP
\&\fICairo::Path\fR is a data structure for holding a path. This data structure
serves as the return value for \f(CW\*(C`$cr\->copy_path\*(C'\fR and
\&\f(CW\*(C`$cr\->copy_path_flat\*(C'\fR as well the input value for
\&\f(CW\*(C`$cr\->append_path\*(C'\fR.
.PP
\&\fICairo::Path\fR is represented as an array reference that contains path
elements, represented by hash references with two keys: \fItype\fR and \fIpoints\fR.
The value for \fItype\fR can be either of the following:
.ie n .IP """move\-to""" 4
.el .IP "\f(CWmove\-to\fR" 4
.IX Item "move-to"
.PD 0
.ie n .IP """line\-to""" 4
.el .IP "\f(CWline\-to\fR" 4
.IX Item "line-to"
.ie n .IP """curve\-to""" 4
.el .IP "\f(CWcurve\-to\fR" 4
.IX Item "curve-to"
.ie n .IP """close\-path""" 4
.el .IP "\f(CWclose\-path\fR" 4
.IX Item "close-path"
.PD
.PP
The value for \fIpoints\fR is an array reference which contains zero or more
points.  Points are represented as array references that contain two doubles:
\&\fIx\fR and \fIy\fR.  The necessary number of points depends on the \fItype\fR of the
path element:
.ie n .IP """move\-to"": 1 point" 4
.el .IP "\f(CWmove\-to\fR: 1 point" 4
.IX Item "move-to: 1 point"
.PD 0
.ie n .IP """line_to"": 1 point" 4
.el .IP "\f(CWline_to\fR: 1 point" 4
.IX Item "line_to: 1 point"
.ie n .IP """curve\-to"": 3 points" 4
.el .IP "\f(CWcurve\-to\fR: 3 points" 4
.IX Item "curve-to: 3 points"
.ie n .IP """close\-path"": 0 points" 4
.el .IP "\f(CWclose\-path\fR: 0 points" 4
.IX Item "close-path: 0 points"
.PD
.PP
The semantics and ordering of the coordinate values are consistent with
\&\f(CW\*(C`$cr\->move_to\*(C'\fR, \f(CW\*(C`$cr\->line_to\*(C'\fR, \f(CW\*(C`$cr\->curve_to\*(C'\fR, and
\&\f(CW\*(C`$cr\->close_path\*(C'\fR.
.PP
Note that the paths returned by Cairo are implemented as tied array references
which do \fBnot\fR support adding, removing or shuffling of path segments.  For
these operations, you need to make a shallow copy first:
.PP
.Vb 2
\&  my @path_clone = @{$path};
\&  # now you can alter @path_clone which ever way you want
.Ve
.PP
The points of a single path element can be changed directly, however, without
the need for a shallow copy:
.PP
.Vb 1
\&  $path\->[$i]{points} = [[3, 4], [5, 6], [7, 8]];
.Ve
.ie n .IP "$path = $cr\->copy_path" 4
.el .IP "\f(CW$path\fR = \f(CW$cr\fR\->copy_path" 4
.IX Item "$path = $cr->copy_path"
.PD 0
.ie n .IP "$path = $cr\->copy_path_flat" 4
.el .IP "\f(CW$path\fR = \f(CW$cr\fR\->copy_path_flat" 4
.IX Item "$path = $cr->copy_path_flat"
.ie n .IP "$cr\->append_path ($path)" 4
.el .IP "\f(CW$cr\fR\->append_path ($path)" 4
.IX Item "$cr->append_path ($path)"
.RS 4
.ie n .IP "$path: \fICairo::Path\fR" 4
.el .IP "\f(CW$path:\fR \fICairo::Path\fR" 4
.IX Item "$path: Cairo::Path"
.RE
.RS 4
.RE
.ie n .IP "$bool = $cr\->has_current_point [1.6]" 4
.el .IP "\f(CW$bool\fR = \f(CW$cr\fR\->has_current_point [1.6]" 4
.IX Item "$bool = $cr->has_current_point [1.6]"
.ie n .IP "($x, $y) = $cr\->get_current_point" 4
.el .IP "($x, \f(CW$y\fR) = \f(CW$cr\fR\->get_current_point" 4
.IX Item "($x, $y) = $cr->get_current_point"
.ie n .IP "$cr\->new_path" 4
.el .IP "\f(CW$cr\fR\->new_path" 4
.IX Item "$cr->new_path"
.ie n .IP "$cr\->new_sub_path [1.2]" 4
.el .IP "\f(CW$cr\fR\->new_sub_path [1.2]" 4
.IX Item "$cr->new_sub_path [1.2]"
.ie n .IP "$cr\->close_path" 4
.el .IP "\f(CW$cr\fR\->close_path" 4
.IX Item "$cr->close_path"
.ie n .IP "($x1, $y1, $x2, $y2) = $cr\->path_extents [1.6]" 4
.el .IP "($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR) = \f(CW$cr\fR\->path_extents [1.6]" 4
.IX Item "($x1, $y1, $x2, $y2) = $cr->path_extents [1.6]"
.ie n .IP "$cr\->arc ($xc, $yc, $radius, $angle1, $angle2)" 4
.el .IP "\f(CW$cr\fR\->arc ($xc, \f(CW$yc\fR, \f(CW$radius\fR, \f(CW$angle1\fR, \f(CW$angle2\fR)" 4
.IX Item "$cr->arc ($xc, $yc, $radius, $angle1, $angle2)"
.RS 4
.ie n .IP "$xc: double" 4
.el .IP "\f(CW$xc:\fR double" 4
.IX Item "$xc: double"
.ie n .IP "$yc: double" 4
.el .IP "\f(CW$yc:\fR double" 4
.IX Item "$yc: double"
.ie n .IP "$radius: double" 4
.el .IP "\f(CW$radius:\fR double" 4
.IX Item "$radius: double"
.ie n .IP "$angle1: double" 4
.el .IP "\f(CW$angle1:\fR double" 4
.IX Item "$angle1: double"
.ie n .IP "$angle2: double" 4
.el .IP "\f(CW$angle2:\fR double" 4
.IX Item "$angle2: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->arc_negative ($xc, $yc, $radius, $angle1, $angle2)" 4
.el .IP "\f(CW$cr\fR\->arc_negative ($xc, \f(CW$yc\fR, \f(CW$radius\fR, \f(CW$angle1\fR, \f(CW$angle2\fR)" 4
.IX Item "$cr->arc_negative ($xc, $yc, $radius, $angle1, $angle2)"
.RS 4
.ie n .IP "$xc: double" 4
.el .IP "\f(CW$xc:\fR double" 4
.IX Item "$xc: double"
.ie n .IP "$yc: double" 4
.el .IP "\f(CW$yc:\fR double" 4
.IX Item "$yc: double"
.ie n .IP "$radius: double" 4
.el .IP "\f(CW$radius:\fR double" 4
.IX Item "$radius: double"
.ie n .IP "$angle1: double" 4
.el .IP "\f(CW$angle1:\fR double" 4
.IX Item "$angle1: double"
.ie n .IP "$angle2: double" 4
.el .IP "\f(CW$angle2:\fR double" 4
.IX Item "$angle2: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->curve_to ($x1, $y1, $x2, $y2, $x3, $y3)" 4
.el .IP "\f(CW$cr\fR\->curve_to ($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$x3\fR, \f(CW$y3\fR)" 4
.IX Item "$cr->curve_to ($x1, $y1, $x2, $y2, $x3, $y3)"
.RS 4
.ie n .IP "$x1: double" 4
.el .IP "\f(CW$x1:\fR double" 4
.IX Item "$x1: double"
.ie n .IP "$y1: double" 4
.el .IP "\f(CW$y1:\fR double" 4
.IX Item "$y1: double"
.ie n .IP "$x2: double" 4
.el .IP "\f(CW$x2:\fR double" 4
.IX Item "$x2: double"
.ie n .IP "$y2: double" 4
.el .IP "\f(CW$y2:\fR double" 4
.IX Item "$y2: double"
.ie n .IP "$x3: double" 4
.el .IP "\f(CW$x3:\fR double" 4
.IX Item "$x3: double"
.ie n .IP "$y3: double" 4
.el .IP "\f(CW$y3:\fR double" 4
.IX Item "$y3: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->line_to ($x, $y)" 4
.el .IP "\f(CW$cr\fR\->line_to ($x, \f(CW$y\fR)" 4
.IX Item "$cr->line_to ($x, $y)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->move_to ($x, $y)" 4
.el .IP "\f(CW$cr\fR\->move_to ($x, \f(CW$y\fR)" 4
.IX Item "$cr->move_to ($x, $y)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->rectangle ($x, $y, $width, $height)" 4
.el .IP "\f(CW$cr\fR\->rectangle ($x, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR)" 4
.IX Item "$cr->rectangle ($x, $y, $width, $height)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.ie n .IP "$width: double" 4
.el .IP "\f(CW$width:\fR double" 4
.IX Item "$width: double"
.ie n .IP "$height: double" 4
.el .IP "\f(CW$height:\fR double" 4
.IX Item "$height: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->glyph_path (...)" 4
.el .IP "\f(CW$cr\fR\->glyph_path (...)" 4
.IX Item "$cr->glyph_path (...)"
.RS 4
.IP "...: list of \fICairo::Glyph\fR's" 4
.IX Item "...: list of Cairo::Glyph's"
.RE
.RS 4
.RE
.ie n .IP "$cr\->text_path ($utf8)" 4
.el .IP "\f(CW$cr\fR\->text_path ($utf8)" 4
.IX Item "$cr->text_path ($utf8)"
.RS 4
.ie n .IP "$utf8: string in utf8 encoding" 4
.el .IP "\f(CW$utf8:\fR string in utf8 encoding" 4
.IX Item "$utf8: string in utf8 encoding"
.RE
.RS 4
.RE
.ie n .IP "$cr\->rel_curve_to ($dx1, $dy1, $dx2, $dy2, $dx3, $dy3)" 4
.el .IP "\f(CW$cr\fR\->rel_curve_to ($dx1, \f(CW$dy1\fR, \f(CW$dx2\fR, \f(CW$dy2\fR, \f(CW$dx3\fR, \f(CW$dy3\fR)" 4
.IX Item "$cr->rel_curve_to ($dx1, $dy1, $dx2, $dy2, $dx3, $dy3)"
.RS 4
.ie n .IP "$dx1: double" 4
.el .IP "\f(CW$dx1:\fR double" 4
.IX Item "$dx1: double"
.ie n .IP "$dy1: double" 4
.el .IP "\f(CW$dy1:\fR double" 4
.IX Item "$dy1: double"
.ie n .IP "$dx2: double" 4
.el .IP "\f(CW$dx2:\fR double" 4
.IX Item "$dx2: double"
.ie n .IP "$dy2: double" 4
.el .IP "\f(CW$dy2:\fR double" 4
.IX Item "$dy2: double"
.ie n .IP "$dx3: double" 4
.el .IP "\f(CW$dx3:\fR double" 4
.IX Item "$dx3: double"
.ie n .IP "$dy3: double" 4
.el .IP "\f(CW$dy3:\fR double" 4
.IX Item "$dy3: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->rel_line_to ($dx, $dy)" 4
.el .IP "\f(CW$cr\fR\->rel_line_to ($dx, \f(CW$dy\fR)" 4
.IX Item "$cr->rel_line_to ($dx, $dy)"
.RS 4
.ie n .IP "$dx: double" 4
.el .IP "\f(CW$dx:\fR double" 4
.IX Item "$dx: double"
.ie n .IP "$dy: double" 4
.el .IP "\f(CW$dy:\fR double" 4
.IX Item "$dy: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->rel_move_to ($dx, $dy)" 4
.el .IP "\f(CW$cr\fR\->rel_move_to ($dx, \f(CW$dy\fR)" 4
.IX Item "$cr->rel_move_to ($dx, $dy)"
.RS 4
.ie n .IP "$dx: double" 4
.el .IP "\f(CW$dx:\fR double" 4
.IX Item "$dx: double"
.ie n .IP "$dy: double" 4
.el .IP "\f(CW$dy:\fR double" 4
.IX Item "$dy: double"
.RE
.RS 4
.RE
.PD
.PP
\fIPatterns \*(-- Gradients and filtered sources\fR
.IX Subsection "Patterns Gradients and filtered sources"
.ie n .IP "$status = $pattern\->status" 4
.el .IP "\f(CW$status\fR = \f(CW$pattern\fR\->status" 4
.IX Item "$status = $pattern->status"
.PD 0
.ie n .IP "$type = $pattern\->get_type [1.2]" 4
.el .IP "\f(CW$type\fR = \f(CW$pattern\fR\->get_type [1.2]" 4
.IX Item "$type = $pattern->get_type [1.2]"
.ie n .IP "$pattern\->set_extend ($extend)" 4
.el .IP "\f(CW$pattern\fR\->set_extend ($extend)" 4
.IX Item "$pattern->set_extend ($extend)"
.RS 4
.ie n .IP "$extend: \fICairo::Extend\fR" 4
.el .IP "\f(CW$extend:\fR \fICairo::Extend\fR" 4
.IX Item "$extend: Cairo::Extend"
.RE
.RS 4
.RE
.ie n .IP "$extend = $pattern\->get_extend" 4
.el .IP "\f(CW$extend\fR = \f(CW$pattern\fR\->get_extend" 4
.IX Item "$extend = $pattern->get_extend"
.ie n .IP "$pattern\->set_filter ($filter)" 4
.el .IP "\f(CW$pattern\fR\->set_filter ($filter)" 4
.IX Item "$pattern->set_filter ($filter)"
.RS 4
.ie n .IP "$filter: \fICairo::Filter\fR" 4
.el .IP "\f(CW$filter:\fR \fICairo::Filter\fR" 4
.IX Item "$filter: Cairo::Filter"
.RE
.RS 4
.RE
.ie n .IP "$filter = $pattern\->get_filter" 4
.el .IP "\f(CW$filter\fR = \f(CW$pattern\fR\->get_filter" 4
.IX Item "$filter = $pattern->get_filter"
.ie n .IP "$pattern\->set_matrix ($matrix)" 4
.el .IP "\f(CW$pattern\fR\->set_matrix ($matrix)" 4
.IX Item "$pattern->set_matrix ($matrix)"
.RS 4
.ie n .IP "$matrix: \fICairo::Matrix\fR" 4
.el .IP "\f(CW$matrix:\fR \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.RE
.RS 4
.RE
.ie n .IP "$matrix = $pattern\->get_matrix" 4
.el .IP "\f(CW$matrix\fR = \f(CW$pattern\fR\->get_matrix" 4
.IX Item "$matrix = $pattern->get_matrix"
.ie n .IP "$pattern = Cairo::SolidPattern\->create_rgb ($red, $green, $blue)" 4
.el .IP "\f(CW$pattern\fR = Cairo::SolidPattern\->create_rgb ($red, \f(CW$green\fR, \f(CW$blue\fR)" 4
.IX Item "$pattern = Cairo::SolidPattern->create_rgb ($red, $green, $blue)"
.RS 4
.ie n .IP "$red: double" 4
.el .IP "\f(CW$red:\fR double" 4
.IX Item "$red: double"
.ie n .IP "$green: double" 4
.el .IP "\f(CW$green:\fR double" 4
.IX Item "$green: double"
.ie n .IP "$blue: double" 4
.el .IP "\f(CW$blue:\fR double" 4
.IX Item "$blue: double"
.RE
.RS 4
.RE
.ie n .IP "$pattern = Cairo::SolidPattern\->create_rgba ($red, $green, $blue, $alpha)" 4
.el .IP "\f(CW$pattern\fR = Cairo::SolidPattern\->create_rgba ($red, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR)" 4
.IX Item "$pattern = Cairo::SolidPattern->create_rgba ($red, $green, $blue, $alpha)"
.RS 4
.ie n .IP "$red: double" 4
.el .IP "\f(CW$red:\fR double" 4
.IX Item "$red: double"
.ie n .IP "$green: double" 4
.el .IP "\f(CW$green:\fR double" 4
.IX Item "$green: double"
.ie n .IP "$blue: double" 4
.el .IP "\f(CW$blue:\fR double" 4
.IX Item "$blue: double"
.ie n .IP "$alpha: double" 4
.el .IP "\f(CW$alpha:\fR double" 4
.IX Item "$alpha: double"
.RE
.RS 4
.RE
.ie n .IP "($r, $g, $b, $a) = $pattern\->get_rgba [1.4]" 4
.el .IP "($r, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR) = \f(CW$pattern\fR\->get_rgba [1.4]" 4
.IX Item "($r, $g, $b, $a) = $pattern->get_rgba [1.4]"
.ie n .IP "$pattern = Cairo::SurfacePattern\->create ($surface)" 4
.el .IP "\f(CW$pattern\fR = Cairo::SurfacePattern\->create ($surface)" 4
.IX Item "$pattern = Cairo::SurfacePattern->create ($surface)"
.RS 4
.ie n .IP "$surface: \fICairo::Surface\fR" 4
.el .IP "\f(CW$surface:\fR \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.RE
.RS 4
.RE
.ie n .IP "$surface = $pattern\->get_surface [1.4]" 4
.el .IP "\f(CW$surface\fR = \f(CW$pattern\fR\->get_surface [1.4]" 4
.IX Item "$surface = $pattern->get_surface [1.4]"
.ie n .IP "$pattern = Cairo::LinearGradient\->create ($x0, $y0, $x1, $y1)" 4
.el .IP "\f(CW$pattern\fR = Cairo::LinearGradient\->create ($x0, \f(CW$y0\fR, \f(CW$x1\fR, \f(CW$y1\fR)" 4
.IX Item "$pattern = Cairo::LinearGradient->create ($x0, $y0, $x1, $y1)"
.RS 4
.ie n .IP "$x0: double" 4
.el .IP "\f(CW$x0:\fR double" 4
.IX Item "$x0: double"
.ie n .IP "$y0: double" 4
.el .IP "\f(CW$y0:\fR double" 4
.IX Item "$y0: double"
.ie n .IP "$x1: double" 4
.el .IP "\f(CW$x1:\fR double" 4
.IX Item "$x1: double"
.ie n .IP "$y1: double" 4
.el .IP "\f(CW$y1:\fR double" 4
.IX Item "$y1: double"
.RE
.RS 4
.RE
.ie n .IP "($x0, $y0, $x1, $y1) = $pattern\->get_points [1.4]" 4
.el .IP "($x0, \f(CW$y0\fR, \f(CW$x1\fR, \f(CW$y1\fR) = \f(CW$pattern\fR\->get_points [1.4]" 4
.IX Item "($x0, $y0, $x1, $y1) = $pattern->get_points [1.4]"
.ie n .IP "$pattern = Cairo::RadialGradient\->create ($cx0, $cy0, $radius0, $cx1, $cy1, $radius1)" 4
.el .IP "\f(CW$pattern\fR = Cairo::RadialGradient\->create ($cx0, \f(CW$cy0\fR, \f(CW$radius0\fR, \f(CW$cx1\fR, \f(CW$cy1\fR, \f(CW$radius1\fR)" 4
.IX Item "$pattern = Cairo::RadialGradient->create ($cx0, $cy0, $radius0, $cx1, $cy1, $radius1)"
.RS 4
.ie n .IP "$cx0: double" 4
.el .IP "\f(CW$cx0:\fR double" 4
.IX Item "$cx0: double"
.ie n .IP "$cy0: double" 4
.el .IP "\f(CW$cy0:\fR double" 4
.IX Item "$cy0: double"
.ie n .IP "$radius0: double" 4
.el .IP "\f(CW$radius0:\fR double" 4
.IX Item "$radius0: double"
.ie n .IP "$cx1: double" 4
.el .IP "\f(CW$cx1:\fR double" 4
.IX Item "$cx1: double"
.ie n .IP "$cy1: double" 4
.el .IP "\f(CW$cy1:\fR double" 4
.IX Item "$cy1: double"
.ie n .IP "$radius1: double" 4
.el .IP "\f(CW$radius1:\fR double" 4
.IX Item "$radius1: double"
.RE
.RS 4
.RE
.ie n .IP "($x0, $y0, $r0, $x1, $y1, $r1) = $pattern\->get_circles [1.4]" 4
.el .IP "($x0, \f(CW$y0\fR, \f(CW$r0\fR, \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$r1\fR) = \f(CW$pattern\fR\->get_circles [1.4]" 4
.IX Item "($x0, $y0, $r0, $x1, $y1, $r1) = $pattern->get_circles [1.4]"
.ie n .IP "$pattern\->add_color_stop_rgb ($offset, $red, $green, $blue)" 4
.el .IP "\f(CW$pattern\fR\->add_color_stop_rgb ($offset, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR)" 4
.IX Item "$pattern->add_color_stop_rgb ($offset, $red, $green, $blue)"
.RS 4
.ie n .IP "$offset: double" 4
.el .IP "\f(CW$offset:\fR double" 4
.IX Item "$offset: double"
.ie n .IP "$red: double" 4
.el .IP "\f(CW$red:\fR double" 4
.IX Item "$red: double"
.ie n .IP "$green: double" 4
.el .IP "\f(CW$green:\fR double" 4
.IX Item "$green: double"
.ie n .IP "$blue: double" 4
.el .IP "\f(CW$blue:\fR double" 4
.IX Item "$blue: double"
.RE
.RS 4
.RE
.ie n .IP "$pattern\->add_color_stop_rgba ($offset, $red, $green, $blue, $alpha)" 4
.el .IP "\f(CW$pattern\fR\->add_color_stop_rgba ($offset, \f(CW$red\fR, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR)" 4
.IX Item "$pattern->add_color_stop_rgba ($offset, $red, $green, $blue, $alpha)"
.RS 4
.ie n .IP "$offset: double" 4
.el .IP "\f(CW$offset:\fR double" 4
.IX Item "$offset: double"
.ie n .IP "$red: double" 4
.el .IP "\f(CW$red:\fR double" 4
.IX Item "$red: double"
.ie n .IP "$green: double" 4
.el .IP "\f(CW$green:\fR double" 4
.IX Item "$green: double"
.ie n .IP "$blue: double" 4
.el .IP "\f(CW$blue:\fR double" 4
.IX Item "$blue: double"
.ie n .IP "$alpha: double" 4
.el .IP "\f(CW$alpha:\fR double" 4
.IX Item "$alpha: double"
.RE
.RS 4
.RE
.ie n .IP "@stops = $pattern\->get_color_stops [1.4]" 4
.el .IP "\f(CW@stops\fR = \f(CW$pattern\fR\->get_color_stops [1.4]" 4
.IX Item "@stops = $pattern->get_color_stops [1.4]"
.PD
A color stop is represented as an array reference with five elements: offset,
red, green, blue, and alpha.
.PP
\fIRegions \*(-- Representing a pixel-aligned area\fR
.IX Subsection "Regions Representing a pixel-aligned area"
.ie n .IP "$region = Cairo::Region\->create (...) [1.10]" 4
.el .IP "\f(CW$region\fR = Cairo::Region\->create (...) [1.10]" 4
.IX Item "$region = Cairo::Region->create (...) [1.10]"
.RS 4
.PD 0
.IP "...: zero or more \fICairo::RectangleInt\fR" 4
.IX Item "...: zero or more Cairo::RectangleInt"
.RE
.RS 4
.RE
.ie n .IP "$status = $region\->status [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$region\fR\->status [1.10]" 4
.IX Item "$status = $region->status [1.10]"
.ie n .IP "$num = $region\->num_rectangles [1.10]" 4
.el .IP "\f(CW$num\fR = \f(CW$region\fR\->num_rectangles [1.10]" 4
.IX Item "$num = $region->num_rectangles [1.10]"
.ie n .IP "$rect = $region\->get_rectangle ($i) [1.10]" 4
.el .IP "\f(CW$rect\fR = \f(CW$region\fR\->get_rectangle ($i) [1.10]" 4
.IX Item "$rect = $region->get_rectangle ($i) [1.10]"
.RS 4
.ie n .IP "$i: integer" 4
.el .IP "\f(CW$i:\fR integer" 4
.IX Item "$i: integer"
.RE
.RS 4
.RE
.ie n .IP "$bool = $region\->is_empty [1.10]" 4
.el .IP "\f(CW$bool\fR = \f(CW$region\fR\->is_empty [1.10]" 4
.IX Item "$bool = $region->is_empty [1.10]"
.ie n .IP "$bool = $region\->contains_point ($x, $y) [1.10]" 4
.el .IP "\f(CW$bool\fR = \f(CW$region\fR\->contains_point ($x, \f(CW$y\fR) [1.10]" 4
.IX Item "$bool = $region->contains_point ($x, $y) [1.10]"
.RS 4
.ie n .IP "$x: integer" 4
.el .IP "\f(CW$x:\fR integer" 4
.IX Item "$x: integer"
.ie n .IP "$y: integer" 4
.el .IP "\f(CW$y:\fR integer" 4
.IX Item "$y: integer"
.RE
.RS 4
.RE
.ie n .IP "$bool = $region_one\->equal ($region_two) [1.10]" 4
.el .IP "\f(CW$bool\fR = \f(CW$region_one\fR\->equal ($region_two) [1.10]" 4
.IX Item "$bool = $region_one->equal ($region_two) [1.10]"
.RS 4
.ie n .IP "$region_two: \fICairo::Region\fR" 4
.el .IP "\f(CW$region_two:\fR \fICairo::Region\fR" 4
.IX Item "$region_two: Cairo::Region"
.RE
.RS 4
.RE
.ie n .IP "$region\->translate ($dx, $dy) [1.10]" 4
.el .IP "\f(CW$region\fR\->translate ($dx, \f(CW$dy\fR) [1.10]" 4
.IX Item "$region->translate ($dx, $dy) [1.10]"
.RS 4
.ie n .IP "$dx: integer" 4
.el .IP "\f(CW$dx:\fR integer" 4
.IX Item "$dx: integer"
.ie n .IP "$dy: integer" 4
.el .IP "\f(CW$dy:\fR integer" 4
.IX Item "$dy: integer"
.RE
.RS 4
.RE
.ie n .IP "$status = $dst\->intersect ($other) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->intersect ($other) [1.10]" 4
.IX Item "$status = $dst->intersect ($other) [1.10]"
.ie n .IP "$status = $dst\->intersect_rectangle ($rect) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->intersect_rectangle ($rect) [1.10]" 4
.IX Item "$status = $dst->intersect_rectangle ($rect) [1.10]"
.ie n .IP "$status = $dst\->subtract ($other) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->subtract ($other) [1.10]" 4
.IX Item "$status = $dst->subtract ($other) [1.10]"
.ie n .IP "$status = $dst\->subtract_rectangle ($rect) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->subtract_rectangle ($rect) [1.10]" 4
.IX Item "$status = $dst->subtract_rectangle ($rect) [1.10]"
.ie n .IP "$status = $dst\->union ($other) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->union ($other) [1.10]" 4
.IX Item "$status = $dst->union ($other) [1.10]"
.ie n .IP "$status = $dst\->union_rectangle ($rect) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->union_rectangle ($rect) [1.10]" 4
.IX Item "$status = $dst->union_rectangle ($rect) [1.10]"
.ie n .IP "$status = $dst\->xor ($other) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->xor ($other) [1.10]" 4
.IX Item "$status = $dst->xor ($other) [1.10]"
.ie n .IP "$status = $dst\->xor_rectangle ($rect) [1.10]" 4
.el .IP "\f(CW$status\fR = \f(CW$dst\fR\->xor_rectangle ($rect) [1.10]" 4
.IX Item "$status = $dst->xor_rectangle ($rect) [1.10]"
.RS 4
.ie n .IP "$other: \fICairo::Region\fR" 4
.el .IP "\f(CW$other:\fR \fICairo::Region\fR" 4
.IX Item "$other: Cairo::Region"
.ie n .IP "$rect: \fICairo::RectangleInt\fR" 4
.el .IP "\f(CW$rect:\fR \fICairo::RectangleInt\fR" 4
.IX Item "$rect: Cairo::RectangleInt"
.RE
.RS 4
.RE
.PD
.PP
\fITransformations \*(-- Manipulating the current transformation matrix\fR
.IX Subsection "Transformations Manipulating the current transformation matrix"
.ie n .IP "$cr\->translate ($tx, $ty)" 4
.el .IP "\f(CW$cr\fR\->translate ($tx, \f(CW$ty\fR)" 4
.IX Item "$cr->translate ($tx, $ty)"
.RS 4
.PD 0
.ie n .IP "$tx: double" 4
.el .IP "\f(CW$tx:\fR double" 4
.IX Item "$tx: double"
.ie n .IP "$ty: double" 4
.el .IP "\f(CW$ty:\fR double" 4
.IX Item "$ty: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->scale ($sx, $sy)" 4
.el .IP "\f(CW$cr\fR\->scale ($sx, \f(CW$sy\fR)" 4
.IX Item "$cr->scale ($sx, $sy)"
.RS 4
.ie n .IP "$sx: double" 4
.el .IP "\f(CW$sx:\fR double" 4
.IX Item "$sx: double"
.ie n .IP "$sy: double" 4
.el .IP "\f(CW$sy:\fR double" 4
.IX Item "$sy: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->rotate ($angle)" 4
.el .IP "\f(CW$cr\fR\->rotate ($angle)" 4
.IX Item "$cr->rotate ($angle)"
.RS 4
.ie n .IP "$angle: double" 4
.el .IP "\f(CW$angle:\fR double" 4
.IX Item "$angle: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->transform ($matrix)" 4
.el .IP "\f(CW$cr\fR\->transform ($matrix)" 4
.IX Item "$cr->transform ($matrix)"
.RS 4
.ie n .IP "$matrix: \fICairo::Matrix\fR" 4
.el .IP "\f(CW$matrix:\fR \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_matrix ($matrix)" 4
.el .IP "\f(CW$cr\fR\->set_matrix ($matrix)" 4
.IX Item "$cr->set_matrix ($matrix)"
.RS 4
.ie n .IP "$matrix: \fICairo::Matrix\fR" 4
.el .IP "\f(CW$matrix:\fR \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.RE
.RS 4
.RE
.ie n .IP "$matrix = $cr\->get_matrix" 4
.el .IP "\f(CW$matrix\fR = \f(CW$cr\fR\->get_matrix" 4
.IX Item "$matrix = $cr->get_matrix"
.ie n .IP "$cr\->identity_matrix" 4
.el .IP "\f(CW$cr\fR\->identity_matrix" 4
.IX Item "$cr->identity_matrix"
.ie n .IP "($x, $y) = $cr\->user_to_device ($x, $y)" 4
.el .IP "($x, \f(CW$y\fR) = \f(CW$cr\fR\->user_to_device ($x, \f(CW$y\fR)" 4
.IX Item "($x, $y) = $cr->user_to_device ($x, $y)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "($dx, $dy) = $cr\->user_to_device_distance ($dx, $dy)" 4
.el .IP "($dx, \f(CW$dy\fR) = \f(CW$cr\fR\->user_to_device_distance ($dx, \f(CW$dy\fR)" 4
.IX Item "($dx, $dy) = $cr->user_to_device_distance ($dx, $dy)"
.RS 4
.ie n .IP "$dx: double" 4
.el .IP "\f(CW$dx:\fR double" 4
.IX Item "$dx: double"
.ie n .IP "$dy: double" 4
.el .IP "\f(CW$dy:\fR double" 4
.IX Item "$dy: double"
.RE
.RS 4
.RE
.ie n .IP "($x, $y) = $cr\->device_to_user ($x, $y)" 4
.el .IP "($x, \f(CW$y\fR) = \f(CW$cr\fR\->device_to_user ($x, \f(CW$y\fR)" 4
.IX Item "($x, $y) = $cr->device_to_user ($x, $y)"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.RE
.RS 4
.RE
.ie n .IP "($dx, $dy) = $cr\->device_to_user_distance ($dx, $dy)" 4
.el .IP "($dx, \f(CW$dy\fR) = \f(CW$cr\fR\->device_to_user_distance ($dx, \f(CW$dy\fR)" 4
.IX Item "($dx, $dy) = $cr->device_to_user_distance ($dx, $dy)"
.RS 4
.ie n .IP "$dx: double" 4
.el .IP "\f(CW$dx:\fR double" 4
.IX Item "$dx: double"
.ie n .IP "$dy: double" 4
.el .IP "\f(CW$dy:\fR double" 4
.IX Item "$dy: double"
.RE
.RS 4
.RE
.PD
.PP
\fIText \*(-- Rendering text and sets of glyphs\fR
.IX Subsection "Text Rendering text and sets of glyphs"
.PP
Glyphs are represented as anonymous hash references with three keys: \fIindex\fR,
\&\fIx\fR and \fIy\fR.  Example:
.PP
.Vb 3
\&  my @glyphs = ({ index => 1, x => 2, y => 3 },
\&                { index => 2, x => 3, y => 4 },
\&                { index => 3, x => 4, y => 5 });
.Ve
.ie n .IP "$cr\->select_font_face ($family, $slant, $weight)" 4
.el .IP "\f(CW$cr\fR\->select_font_face ($family, \f(CW$slant\fR, \f(CW$weight\fR)" 4
.IX Item "$cr->select_font_face ($family, $slant, $weight)"
.RS 4
.PD 0
.ie n .IP "$family: string" 4
.el .IP "\f(CW$family:\fR string" 4
.IX Item "$family: string"
.ie n .IP "$slant: \fICairo::FontSlant\fR" 4
.el .IP "\f(CW$slant:\fR \fICairo::FontSlant\fR" 4
.IX Item "$slant: Cairo::FontSlant"
.ie n .IP "$weight: \fICairo::FontWeight\fR" 4
.el .IP "\f(CW$weight:\fR \fICairo::FontWeight\fR" 4
.IX Item "$weight: Cairo::FontWeight"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_font_size ($size)" 4
.el .IP "\f(CW$cr\fR\->set_font_size ($size)" 4
.IX Item "$cr->set_font_size ($size)"
.RS 4
.ie n .IP "$size: double" 4
.el .IP "\f(CW$size:\fR double" 4
.IX Item "$size: double"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_font_matrix ($matrix)" 4
.el .IP "\f(CW$cr\fR\->set_font_matrix ($matrix)" 4
.IX Item "$cr->set_font_matrix ($matrix)"
.RS 4
.ie n .IP "$matrix: \fICairo::Matrix\fR" 4
.el .IP "\f(CW$matrix:\fR \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.RE
.RS 4
.RE
.ie n .IP "$matrix = $cr\->get_font_matrix" 4
.el .IP "\f(CW$matrix\fR = \f(CW$cr\fR\->get_font_matrix" 4
.IX Item "$matrix = $cr->get_font_matrix"
.ie n .IP "$cr\->set_font_options ($options)" 4
.el .IP "\f(CW$cr\fR\->set_font_options ($options)" 4
.IX Item "$cr->set_font_options ($options)"
.RS 4
.ie n .IP "$options: \fICairo::FontOptions\fR" 4
.el .IP "\f(CW$options:\fR \fICairo::FontOptions\fR" 4
.IX Item "$options: Cairo::FontOptions"
.RE
.RS 4
.RE
.ie n .IP "$options = $cr\->get_font_options" 4
.el .IP "\f(CW$options\fR = \f(CW$cr\fR\->get_font_options" 4
.IX Item "$options = $cr->get_font_options"
.ie n .IP "$cr\->set_scaled_font ($scaled_font) [1.2]" 4
.el .IP "\f(CW$cr\fR\->set_scaled_font ($scaled_font) [1.2]" 4
.IX Item "$cr->set_scaled_font ($scaled_font) [1.2]"
.RS 4
.ie n .IP "$scaled_font: \fICairo::ScaledFont\fR" 4
.el .IP "\f(CW$scaled_font:\fR \fICairo::ScaledFont\fR" 4
.IX Item "$scaled_font: Cairo::ScaledFont"
.RE
.RS 4
.RE
.ie n .IP "$scaled_font = $cr\->get_scaled_font [1.4]" 4
.el .IP "\f(CW$scaled_font\fR = \f(CW$cr\fR\->get_scaled_font [1.4]" 4
.IX Item "$scaled_font = $cr->get_scaled_font [1.4]"
.ie n .IP "$cr\->show_text ($utf8)" 4
.el .IP "\f(CW$cr\fR\->show_text ($utf8)" 4
.IX Item "$cr->show_text ($utf8)"
.RS 4
.ie n .IP "$utf8: string" 4
.el .IP "\f(CW$utf8:\fR string" 4
.IX Item "$utf8: string"
.RE
.RS 4
.RE
.ie n .IP "$cr\->show_glyphs (...)" 4
.el .IP "\f(CW$cr\fR\->show_glyphs (...)" 4
.IX Item "$cr->show_glyphs (...)"
.RS 4
.IP "...: list of glyphs" 4
.IX Item "...: list of glyphs"
.RE
.RS 4
.RE
.ie n .IP "$cr\->show_text_glyphs ($utf8, $glyphs, $clusters, $cluster_flags) [1.8]" 4
.el .IP "\f(CW$cr\fR\->show_text_glyphs ($utf8, \f(CW$glyphs\fR, \f(CW$clusters\fR, \f(CW$cluster_flags\fR) [1.8]" 4
.IX Item "$cr->show_text_glyphs ($utf8, $glyphs, $clusters, $cluster_flags) [1.8]"
.RS 4
.ie n .IP "$utf8: string" 4
.el .IP "\f(CW$utf8:\fR string" 4
.IX Item "$utf8: string"
.ie n .IP "$glyphs: array ref of glyphs" 4
.el .IP "\f(CW$glyphs:\fR array ref of glyphs" 4
.IX Item "$glyphs: array ref of glyphs"
.ie n .IP "$clusters: array ref of clusters" 4
.el .IP "\f(CW$clusters:\fR array ref of clusters" 4
.IX Item "$clusters: array ref of clusters"
.ie n .IP "$cluster_flags: \fICairo::TextClusterFlags\fR" 4
.el .IP "\f(CW$cluster_flags:\fR \fICairo::TextClusterFlags\fR" 4
.IX Item "$cluster_flags: Cairo::TextClusterFlags"
.RE
.RS 4
.RE
.ie n .IP "$face = $cr\->get_font_face" 4
.el .IP "\f(CW$face\fR = \f(CW$cr\fR\->get_font_face" 4
.IX Item "$face = $cr->get_font_face"
.ie n .IP "$extents = $cr\->font_extents" 4
.el .IP "\f(CW$extents\fR = \f(CW$cr\fR\->font_extents" 4
.IX Item "$extents = $cr->font_extents"
.ie n .IP "$cr\->set_font_face ($font_face)" 4
.el .IP "\f(CW$cr\fR\->set_font_face ($font_face)" 4
.IX Item "$cr->set_font_face ($font_face)"
.RS 4
.ie n .IP "$font_face: \fICairo::FontFace\fR" 4
.el .IP "\f(CW$font_face:\fR \fICairo::FontFace\fR" 4
.IX Item "$font_face: Cairo::FontFace"
.RE
.RS 4
.RE
.ie n .IP "$cr\->set_scaled_font ($scaled_font)" 4
.el .IP "\f(CW$cr\fR\->set_scaled_font ($scaled_font)" 4
.IX Item "$cr->set_scaled_font ($scaled_font)"
.RS 4
.ie n .IP "$scaled_font: \fICairo::ScaledFont\fR" 4
.el .IP "\f(CW$scaled_font:\fR \fICairo::ScaledFont\fR" 4
.IX Item "$scaled_font: Cairo::ScaledFont"
.RE
.RS 4
.RE
.ie n .IP "$extents = $cr\->text_extents ($utf8)" 4
.el .IP "\f(CW$extents\fR = \f(CW$cr\fR\->text_extents ($utf8)" 4
.IX Item "$extents = $cr->text_extents ($utf8)"
.RS 4
.ie n .IP "$utf8: string" 4
.el .IP "\f(CW$utf8:\fR string" 4
.IX Item "$utf8: string"
.RE
.RS 4
.RE
.ie n .IP "$extents = $cr\->glyph_extents (...)" 4
.el .IP "\f(CW$extents\fR = \f(CW$cr\fR\->glyph_extents (...)" 4
.IX Item "$extents = $cr->glyph_extents (...)"
.RS 4
.IP "...: list of glyphs" 4
.IX Item "...: list of glyphs"
.RE
.RS 4
.RE
.ie n .IP "$face = Cairo::ToyFontFace\->create ($family, $slant, $weight) [1.8]" 4
.el .IP "\f(CW$face\fR = Cairo::ToyFontFace\->create ($family, \f(CW$slant\fR, \f(CW$weight\fR) [1.8]" 4
.IX Item "$face = Cairo::ToyFontFace->create ($family, $slant, $weight) [1.8]"
.RS 4
.ie n .IP "$family: string" 4
.el .IP "\f(CW$family:\fR string" 4
.IX Item "$family: string"
.ie n .IP "$slant: \fICairo::FontSlant\fR" 4
.el .IP "\f(CW$slant:\fR \fICairo::FontSlant\fR" 4
.IX Item "$slant: Cairo::FontSlant"
.ie n .IP "$weight: \fICairo::FontWeight\fR" 4
.el .IP "\f(CW$weight:\fR \fICairo::FontWeight\fR" 4
.IX Item "$weight: Cairo::FontWeight"
.RE
.RS 4
.RE
.ie n .IP "$family = $face\->get_family [1.8]" 4
.el .IP "\f(CW$family\fR = \f(CW$face\fR\->get_family [1.8]" 4
.IX Item "$family = $face->get_family [1.8]"
.ie n .IP "$slang = $face\->get_slant [1.8]" 4
.el .IP "\f(CW$slang\fR = \f(CW$face\fR\->get_slant [1.8]" 4
.IX Item "$slang = $face->get_slant [1.8]"
.ie n .IP "$weight = $face\->get_weight [1.8]" 4
.el .IP "\f(CW$weight\fR = \f(CW$face\fR\->get_weight [1.8]" 4
.IX Item "$weight = $face->get_weight [1.8]"
.PD
.SS "Fonts"
.IX Subsection "Fonts"
\fICairo::FontFace \*(-- Base class for fonts\fR
.IX Subsection "Cairo::FontFace Base class for fonts"
.ie n .IP "$status = $font_face\->status" 4
.el .IP "\f(CW$status\fR = \f(CW$font_face\fR\->status" 4
.IX Item "$status = $font_face->status"
.PD 0
.ie n .IP "$type = $font_face\->get_type [1.2]" 4
.el .IP "\f(CW$type\fR = \f(CW$font_face\fR\->get_type [1.2]" 4
.IX Item "$type = $font_face->get_type [1.2]"
.PD
.PP
\fIScaled Fonts \*(-- Caching metrics for a particular font size\fR
.IX Subsection "Scaled Fonts Caching metrics for a particular font size"
.ie n .IP "$scaled_font = Cairo::ScaledFont\->create ($font_face, $font_matrix, $ctm, $options)" 4
.el .IP "\f(CW$scaled_font\fR = Cairo::ScaledFont\->create ($font_face, \f(CW$font_matrix\fR, \f(CW$ctm\fR, \f(CW$options\fR)" 4
.IX Item "$scaled_font = Cairo::ScaledFont->create ($font_face, $font_matrix, $ctm, $options)"
.RS 4
.PD 0
.ie n .IP "$font_face: \fICairo::FontFace\fR" 4
.el .IP "\f(CW$font_face:\fR \fICairo::FontFace\fR" 4
.IX Item "$font_face: Cairo::FontFace"
.ie n .IP "$font_matrix: \fICairo::Matrix\fR" 4
.el .IP "\f(CW$font_matrix:\fR \fICairo::Matrix\fR" 4
.IX Item "$font_matrix: Cairo::Matrix"
.ie n .IP "$ctm: \fICairo::Matrix\fR" 4
.el .IP "\f(CW$ctm:\fR \fICairo::Matrix\fR" 4
.IX Item "$ctm: Cairo::Matrix"
.ie n .IP "$options: \fICairo::FontOptions\fR" 4
.el .IP "\f(CW$options:\fR \fICairo::FontOptions\fR" 4
.IX Item "$options: Cairo::FontOptions"
.RE
.RS 4
.RE
.ie n .IP "$status = $scaled_font\->status" 4
.el .IP "\f(CW$status\fR = \f(CW$scaled_font\fR\->status" 4
.IX Item "$status = $scaled_font->status"
.ie n .IP "$extents = $scaled_font\->extents" 4
.el .IP "\f(CW$extents\fR = \f(CW$scaled_font\fR\->extents" 4
.IX Item "$extents = $scaled_font->extents"
.ie n .IP "$extents = $scaled_font\->text_extents ($utf8) [1.2]" 4
.el .IP "\f(CW$extents\fR = \f(CW$scaled_font\fR\->text_extents ($utf8) [1.2]" 4
.IX Item "$extents = $scaled_font->text_extents ($utf8) [1.2]"
.RS 4
.ie n .IP "$utf8: string" 4
.el .IP "\f(CW$utf8:\fR string" 4
.IX Item "$utf8: string"
.RE
.RS 4
.RE
.ie n .IP "$extents = $scaled_font\->glyph_extents (...)" 4
.el .IP "\f(CW$extents\fR = \f(CW$scaled_font\fR\->glyph_extents (...)" 4
.IX Item "$extents = $scaled_font->glyph_extents (...)"
.RS 4
.IP "...: list of glyphs" 4
.IX Item "...: list of glyphs"
.RE
.RS 4
.RE
.ie n .IP "($status, $glyphs, $clusters, $cluster_flags) = $scaled_font\->text_to_glyphs ($x, $y, $utf8) [1.8]" 4
.el .IP "($status, \f(CW$glyphs\fR, \f(CW$clusters\fR, \f(CW$cluster_flags\fR) = \f(CW$scaled_font\fR\->text_to_glyphs ($x, \f(CW$y\fR, \f(CW$utf8\fR) [1.8]" 4
.IX Item "($status, $glyphs, $clusters, $cluster_flags) = $scaled_font->text_to_glyphs ($x, $y, $utf8) [1.8]"
.RS 4
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.ie n .IP "$utf8: string" 4
.el .IP "\f(CW$utf8:\fR string" 4
.IX Item "$utf8: string"
.RE
.RS 4
.RE
.ie n .IP "$font_face = $scaled_font\->get_font_face [1.2]" 4
.el .IP "\f(CW$font_face\fR = \f(CW$scaled_font\fR\->get_font_face [1.2]" 4
.IX Item "$font_face = $scaled_font->get_font_face [1.2]"
.ie n .IP "$options = $scaled_font\->get_font_options [1.2]" 4
.el .IP "\f(CW$options\fR = \f(CW$scaled_font\fR\->get_font_options [1.2]" 4
.IX Item "$options = $scaled_font->get_font_options [1.2]"
.ie n .IP "$font_matrix = $scaled_font\->get_font_matrix [1.2]" 4
.el .IP "\f(CW$font_matrix\fR = \f(CW$scaled_font\fR\->get_font_matrix [1.2]" 4
.IX Item "$font_matrix = $scaled_font->get_font_matrix [1.2]"
.ie n .IP "$ctm = $scaled_font\->get_ctm [1.2]" 4
.el .IP "\f(CW$ctm\fR = \f(CW$scaled_font\fR\->get_ctm [1.2]" 4
.IX Item "$ctm = $scaled_font->get_ctm [1.2]"
.ie n .IP "$scale_matrix = $scaled_font\->get_scale_matrix [1.8]" 4
.el .IP "\f(CW$scale_matrix\fR = \f(CW$scaled_font\fR\->get_scale_matrix [1.8]" 4
.IX Item "$scale_matrix = $scaled_font->get_scale_matrix [1.8]"
.ie n .IP "$type = $scaled_font\->get_type [1.2]" 4
.el .IP "\f(CW$type\fR = \f(CW$scaled_font\fR\->get_type [1.2]" 4
.IX Item "$type = $scaled_font->get_type [1.2]"
.PD
.PP
\fIFont Options \*(-- How a font should be rendered\fR
.IX Subsection "Font Options How a font should be rendered"
.ie n .IP "$font_options = Cairo::FontOptions\->create" 4
.el .IP "\f(CW$font_options\fR = Cairo::FontOptions\->create" 4
.IX Item "$font_options = Cairo::FontOptions->create"
.PD 0
.ie n .IP "$status = $font_options\->status" 4
.el .IP "\f(CW$status\fR = \f(CW$font_options\fR\->status" 4
.IX Item "$status = $font_options->status"
.ie n .IP "$font_options\->merge ($other)" 4
.el .IP "\f(CW$font_options\fR\->merge ($other)" 4
.IX Item "$font_options->merge ($other)"
.RS 4
.ie n .IP "$other: \fICairo::FontOptions\fR" 4
.el .IP "\f(CW$other:\fR \fICairo::FontOptions\fR" 4
.IX Item "$other: Cairo::FontOptions"
.RE
.RS 4
.RE
.ie n .IP "$hash = $font_options\->hash" 4
.el .IP "\f(CW$hash\fR = \f(CW$font_options\fR\->hash" 4
.IX Item "$hash = $font_options->hash"
.ie n .IP "$bools = $font_options\->equal ($other)" 4
.el .IP "\f(CW$bools\fR = \f(CW$font_options\fR\->equal ($other)" 4
.IX Item "$bools = $font_options->equal ($other)"
.RS 4
.ie n .IP "$other: \fICairo::FontOptions\fR" 4
.el .IP "\f(CW$other:\fR \fICairo::FontOptions\fR" 4
.IX Item "$other: Cairo::FontOptions"
.RE
.RS 4
.RE
.ie n .IP "$font_options\->set_antialias ($antialias)" 4
.el .IP "\f(CW$font_options\fR\->set_antialias ($antialias)" 4
.IX Item "$font_options->set_antialias ($antialias)"
.RS 4
.ie n .IP "$antialias: \fICairo::AntiAlias\fR" 4
.el .IP "\f(CW$antialias:\fR \fICairo::AntiAlias\fR" 4
.IX Item "$antialias: Cairo::AntiAlias"
.RE
.RS 4
.RE
.ie n .IP "$antialias = $font_options\->get_antialias" 4
.el .IP "\f(CW$antialias\fR = \f(CW$font_options\fR\->get_antialias" 4
.IX Item "$antialias = $font_options->get_antialias"
.ie n .IP "$font_options\->set_subpixel_order ($subpixel_order)" 4
.el .IP "\f(CW$font_options\fR\->set_subpixel_order ($subpixel_order)" 4
.IX Item "$font_options->set_subpixel_order ($subpixel_order)"
.RS 4
.ie n .IP "$subpixel_order: \fICairo::SubpixelOrder\fR" 4
.el .IP "\f(CW$subpixel_order:\fR \fICairo::SubpixelOrder\fR" 4
.IX Item "$subpixel_order: Cairo::SubpixelOrder"
.RE
.RS 4
.RE
.ie n .IP "$subpixel_order = $font_options\->get_subpixel_order" 4
.el .IP "\f(CW$subpixel_order\fR = \f(CW$font_options\fR\->get_subpixel_order" 4
.IX Item "$subpixel_order = $font_options->get_subpixel_order"
.ie n .IP "$font_options\->set_hint_style ($hint_style)" 4
.el .IP "\f(CW$font_options\fR\->set_hint_style ($hint_style)" 4
.IX Item "$font_options->set_hint_style ($hint_style)"
.RS 4
.ie n .IP "$hint_style: \fICairo::HintStyle\fR" 4
.el .IP "\f(CW$hint_style:\fR \fICairo::HintStyle\fR" 4
.IX Item "$hint_style: Cairo::HintStyle"
.RE
.RS 4
.RE
.ie n .IP "$hint_style = $font_options\->get_hint_style" 4
.el .IP "\f(CW$hint_style\fR = \f(CW$font_options\fR\->get_hint_style" 4
.IX Item "$hint_style = $font_options->get_hint_style"
.ie n .IP "$font_options\->set_hint_metrics ($hint_metrics)" 4
.el .IP "\f(CW$font_options\fR\->set_hint_metrics ($hint_metrics)" 4
.IX Item "$font_options->set_hint_metrics ($hint_metrics)"
.RS 4
.ie n .IP "$hint_metrics: \fICairo::HintMetrics\fR" 4
.el .IP "\f(CW$hint_metrics:\fR \fICairo::HintMetrics\fR" 4
.IX Item "$hint_metrics: Cairo::HintMetrics"
.RE
.RS 4
.RE
.ie n .IP "$hint_metrics = $font_options\->get_hint_metrics" 4
.el .IP "\f(CW$hint_metrics\fR = \f(CW$font_options\fR\->get_hint_metrics" 4
.IX Item "$hint_metrics = $font_options->get_hint_metrics"
.PD
.PP
\fIFreeType Fonts \*(-- Font support for FreeType\fR
.IX Subsection "FreeType Fonts Font support for FreeType"
.PP
If your cairo library supports it, the FreeType integration allows you to load
font faces from font files.  You can query for this capability with
\&\f(CW\*(C`Cairo::HAS_FT_FONT\*(C'\fR.  To actually use this, you'll need the Font::FreeType
module.
.ie n .IP "my $face = Cairo::FtFontFace\->create ($ft_face, $load_flags=0)" 4
.el .IP "my \f(CW$face\fR = Cairo::FtFontFace\->create ($ft_face, \f(CW$load_flags\fR=0)" 4
.IX Item "my $face = Cairo::FtFontFace->create ($ft_face, $load_flags=0)"
.RS 4
.PD 0
.ie n .IP "$ft_face: \fIFont::FreeType::Face\fR" 4
.el .IP "\f(CW$ft_face:\fR \fIFont::FreeType::Face\fR" 4
.IX Item "$ft_face: Font::FreeType::Face"
.ie n .IP "$load_flags: integer" 4
.el .IP "\f(CW$load_flags:\fR integer" 4
.IX Item "$load_flags: integer"
.RE
.RS 4
.PD
.Sp
This method allows you to create a \fICairo::FontFace\fR from a
\&\fIFont::FreeType::Face\fR.  To obtain the latter, you can for example load it
from a file:
.Sp
.Vb 3
\&  my $file = \*(Aq/usr/share/fonts/truetype/ttf\-bitstream\-vera/Vera.ttf\*(Aq;
\&  my $ft_face = Font::FreeType\->new\->face ($file);
\&  my $face = Cairo::FtFontFace\->create ($ft_face);
.Ve
.RE
.SS "Surfaces"
.IX Subsection "Surfaces"
\fI\fICairo::Surface\fI \*(-- Base class for surfaces\fR
.IX Subsection "Cairo::Surface Base class for surfaces"
.ie n .IP "$similar = Cairo::Surface\->create_similar ($other, $content, $width, $height)" 4
.el .IP "\f(CW$similar\fR = Cairo::Surface\->create_similar ($other, \f(CW$content\fR, \f(CW$width\fR, \f(CW$height\fR)" 4
.IX Item "$similar = Cairo::Surface->create_similar ($other, $content, $width, $height)"
.RS 4
.PD 0
.ie n .IP "$other: \fICairo::Surface\fR" 4
.el .IP "\f(CW$other:\fR \fICairo::Surface\fR" 4
.IX Item "$other: Cairo::Surface"
.ie n .IP "$content: \fICairo::Content\fR" 4
.el .IP "\f(CW$content:\fR \fICairo::Content\fR" 4
.IX Item "$content: Cairo::Content"
.ie n .IP "$width: integer" 4
.el .IP "\f(CW$width:\fR integer" 4
.IX Item "$width: integer"
.ie n .IP "$height: integer" 4
.el .IP "\f(CW$height:\fR integer" 4
.IX Item "$height: integer"
.RE
.RS 4
.PD
.Sp
For hysterical reasons, you can also use the following syntax:
.Sp
.Vb 1
\&  $similar = $other\->create_similar ($content, $width, $height)
.Ve
.RE
.ie n .IP "$new = Cairo::Surface\->create_for_rectangle ($target, $x, $y, $width, $height) [1.10]" 4
.el .IP "\f(CW$new\fR = Cairo::Surface\->create_for_rectangle ($target, \f(CW$x\fR, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR) [1.10]" 4
.IX Item "$new = Cairo::Surface->create_for_rectangle ($target, $x, $y, $width, $height) [1.10]"
.RS 4
.PD 0
.ie n .IP "$target: \fICairo::Surface\fR" 4
.el .IP "\f(CW$target:\fR \fICairo::Surface\fR" 4
.IX Item "$target: Cairo::Surface"
.ie n .IP "$x: double" 4
.el .IP "\f(CW$x:\fR double" 4
.IX Item "$x: double"
.ie n .IP "$y: double" 4
.el .IP "\f(CW$y:\fR double" 4
.IX Item "$y: double"
.ie n .IP "$width: double" 4
.el .IP "\f(CW$width:\fR double" 4
.IX Item "$width: double"
.ie n .IP "$height: double" 4
.el .IP "\f(CW$height:\fR double" 4
.IX Item "$height: double"
.RE
.RS 4
.RE
.ie n .IP "$status = $surface\->status" 4
.el .IP "\f(CW$status\fR = \f(CW$surface\fR\->status" 4
.IX Item "$status = $surface->status"
.ie n .IP "$surface\->finish" 4
.el .IP "\f(CW$surface\fR\->finish" 4
.IX Item "$surface->finish"
.ie n .IP "$surface\->flush" 4
.el .IP "\f(CW$surface\fR\->flush" 4
.IX Item "$surface->flush"
.ie n .IP "$font_options = $surface\->get_font_options" 4
.el .IP "\f(CW$font_options\fR = \f(CW$surface\fR\->get_font_options" 4
.IX Item "$font_options = $surface->get_font_options"
.ie n .IP "$content = $surface\->get_content [1.2]" 4
.el .IP "\f(CW$content\fR = \f(CW$surface\fR\->get_content [1.2]" 4
.IX Item "$content = $surface->get_content [1.2]"
.ie n .IP "$surface\->mark_dirty" 4
.el .IP "\f(CW$surface\fR\->mark_dirty" 4
.IX Item "$surface->mark_dirty"
.ie n .IP "$surface\->mark_dirty_rectangle ($x, $y, $width, $height)" 4
.el .IP "\f(CW$surface\fR\->mark_dirty_rectangle ($x, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR)" 4
.IX Item "$surface->mark_dirty_rectangle ($x, $y, $width, $height)"
.RS 4
.ie n .IP "$x: integer" 4
.el .IP "\f(CW$x:\fR integer" 4
.IX Item "$x: integer"
.ie n .IP "$y: integer" 4
.el .IP "\f(CW$y:\fR integer" 4
.IX Item "$y: integer"
.ie n .IP "$width: integer" 4
.el .IP "\f(CW$width:\fR integer" 4
.IX Item "$width: integer"
.ie n .IP "$height: integer" 4
.el .IP "\f(CW$height:\fR integer" 4
.IX Item "$height: integer"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_device_offset ($x_offset, $y_offset)" 4
.el .IP "\f(CW$surface\fR\->set_device_offset ($x_offset, \f(CW$y_offset\fR)" 4
.IX Item "$surface->set_device_offset ($x_offset, $y_offset)"
.RS 4
.ie n .IP "$x_offset: integer" 4
.el .IP "\f(CW$x_offset:\fR integer" 4
.IX Item "$x_offset: integer"
.ie n .IP "$y_offset: integer" 4
.el .IP "\f(CW$y_offset:\fR integer" 4
.IX Item "$y_offset: integer"
.RE
.RS 4
.RE
.ie n .IP "($x_offset, $y_offset) = $surface\->get_device_offset [1.2]" 4
.el .IP "($x_offset, \f(CW$y_offset\fR) = \f(CW$surface\fR\->get_device_offset [1.2]" 4
.IX Item "($x_offset, $y_offset) = $surface->get_device_offset [1.2]"
.ie n .IP "$surface\->set_fallback_resolution ($x_pixels_per_inch, $y_pixels_per_inch) [1.2]" 4
.el .IP "\f(CW$surface\fR\->set_fallback_resolution ($x_pixels_per_inch, \f(CW$y_pixels_per_inch\fR) [1.2]" 4
.IX Item "$surface->set_fallback_resolution ($x_pixels_per_inch, $y_pixels_per_inch) [1.2]"
.RS 4
.ie n .IP "$x_pixels_per_inch: double" 4
.el .IP "\f(CW$x_pixels_per_inch:\fR double" 4
.IX Item "$x_pixels_per_inch: double"
.ie n .IP "$y_pixels_per_inch: double" 4
.el .IP "\f(CW$y_pixels_per_inch:\fR double" 4
.IX Item "$y_pixels_per_inch: double"
.RE
.RS 4
.RE
.ie n .IP "($x_pixels_per_inch, $y_pixels_per_inch) = $surface\->get_fallback_resolution [1.8]" 4
.el .IP "($x_pixels_per_inch, \f(CW$y_pixels_per_inch\fR) = \f(CW$surface\fR\->get_fallback_resolution [1.8]" 4
.IX Item "($x_pixels_per_inch, $y_pixels_per_inch) = $surface->get_fallback_resolution [1.8]"
.ie n .IP "$type = $surface\->get_type [1.2]" 4
.el .IP "\f(CW$type\fR = \f(CW$surface\fR\->get_type [1.2]" 4
.IX Item "$type = $surface->get_type [1.2]"
.ie n .IP "$surface\->set_mime_data ($mime_type, $mime_data) [1.10]" 4
.el .IP "\f(CW$surface\fR\->set_mime_data ($mime_type, \f(CW$mime_data\fR) [1.10]" 4
.IX Item "$surface->set_mime_data ($mime_type, $mime_data) [1.10]"
.ie n .IP "$mime_data = $surface\->get_mime_data ($mime_type) [1.10]" 4
.el .IP "\f(CW$mime_data\fR = \f(CW$surface\fR\->get_mime_data ($mime_type) [1.10]" 4
.IX Item "$mime_data = $surface->get_mime_data ($mime_type) [1.10]"
.ie n .IP "$bool = $surface\->supports_mime_type ($mime_type) [1.12]" 4
.el .IP "\f(CW$bool\fR = \f(CW$surface\fR\->supports_mime_type ($mime_type) [1.12]" 4
.IX Item "$bool = $surface->supports_mime_type ($mime_type) [1.12]"
.RS 4
.ie n .IP "$mime_type: string" 4
.el .IP "\f(CW$mime_type:\fR string" 4
.IX Item "$mime_type: string"
.RS 4
.IP "Predefined \s-1MIME\s0 types:" 4
.IX Item "Predefined MIME types:"
.RS 4
.IP "Cairo::Surface::MIME_TYPE_JP2 [1.10]" 4
.IX Item "Cairo::Surface::MIME_TYPE_JP2 [1.10]"
.IP "Cairo::Surface::MIME_TYPE_JPEG [1.10]" 4
.IX Item "Cairo::Surface::MIME_TYPE_JPEG [1.10]"
.IP "Cairo::Surface::MIME_TYPE_PNG [1.10]" 4
.IX Item "Cairo::Surface::MIME_TYPE_PNG [1.10]"
.IP "Cairo::Surface::MIME_TYPE_URI [1.10]" 4
.IX Item "Cairo::Surface::MIME_TYPE_URI [1.10]"
.IP "Cairo::Surface::MIME_TYPE_UNIQUE_ID [1.12]" 4
.IX Item "Cairo::Surface::MIME_TYPE_UNIQUE_ID [1.12]"
.IP "Cairo::Surface::MIME_TYPE_JBIG2 [1.14]" 4
.IX Item "Cairo::Surface::MIME_TYPE_JBIG2 [1.14]"
.IP "Cairo::Surface::MIME_TYPE_JBIG2_GLOBAL [1.14]" 4
.IX Item "Cairo::Surface::MIME_TYPE_JBIG2_GLOBAL [1.14]"
.IP "Cairo::Surface::MIME_TYPE_JBIG2_GLOBAL_PARAMS [1.14]" 4
.IX Item "Cairo::Surface::MIME_TYPE_JBIG2_GLOBAL_PARAMS [1.14]"
.IP "Cairo::Surface::MIME_TYPE_CCITT_FAX [1.16]" 4
.IX Item "Cairo::Surface::MIME_TYPE_CCITT_FAX [1.16]"
.IP "Cairo::Surface::MIME_TYPE_CCITT_FAX_PARAMS [1.16]" 4
.IX Item "Cairo::Surface::MIME_TYPE_CCITT_FAX_PARAMS [1.16]"
.IP "Cairo::Surface::MIME_TYPE_EPS [1.16]" 4
.IX Item "Cairo::Surface::MIME_TYPE_EPS [1.16]"
.IP "Cairo::Surface::MIME_TYPE_EPS_PARAMS [1.16]" 4
.IX Item "Cairo::Surface::MIME_TYPE_EPS_PARAMS [1.16]"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .IP "$mime_data: binary data string" 4
.el .IP "\f(CW$mime_data:\fR binary data string" 4
.IX Item "$mime_data: binary data string"
.RE
.RS 4
.RE
.ie n .IP "$status = $surface\->copy_page [1.6]" 4
.el .IP "\f(CW$status\fR = \f(CW$surface\fR\->copy_page [1.6]" 4
.IX Item "$status = $surface->copy_page [1.6]"
.RS 4
.ie n .IP "$status: \fICairo::Status\fR" 4
.el .IP "\f(CW$status:\fR \fICairo::Status\fR" 4
.IX Item "$status: Cairo::Status"
.RE
.RS 4
.RE
.ie n .IP "$status = $surface\->show_page [1.6]" 4
.el .IP "\f(CW$status\fR = \f(CW$surface\fR\->show_page [1.6]" 4
.IX Item "$status = $surface->show_page [1.6]"
.RS 4
.ie n .IP "$status: \fICairo::Status\fR" 4
.el .IP "\f(CW$status:\fR \fICairo::Status\fR" 4
.IX Item "$status: Cairo::Status"
.RE
.RS 4
.RE
.ie n .IP "$boolean = $surface\->has_show_text_glyphs [1.8]" 4
.el .IP "\f(CW$boolean\fR = \f(CW$surface\fR\->has_show_text_glyphs [1.8]" 4
.IX Item "$boolean = $surface->has_show_text_glyphs [1.8]"
.PD
.PP
\fIImage Surfaces \*(-- Rendering to memory buffers\fR
.IX Subsection "Image Surfaces Rendering to memory buffers"
.ie n .IP "$surface = Cairo::ImageSurface\->create ($format, $width, $height)" 4
.el .IP "\f(CW$surface\fR = Cairo::ImageSurface\->create ($format, \f(CW$width\fR, \f(CW$height\fR)" 4
.IX Item "$surface = Cairo::ImageSurface->create ($format, $width, $height)"
.RS 4
.PD 0
.ie n .IP "$format: \fICairo::Format\fR" 4
.el .IP "\f(CW$format:\fR \fICairo::Format\fR" 4
.IX Item "$format: Cairo::Format"
.ie n .IP "$width: integer" 4
.el .IP "\f(CW$width:\fR integer" 4
.IX Item "$width: integer"
.ie n .IP "$height: integer" 4
.el .IP "\f(CW$height:\fR integer" 4
.IX Item "$height: integer"
.RE
.RS 4
.RE
.ie n .IP "$surface = Cairo::ImageSurface\->create_for_data ($data, $format, $width, $height, $stride)" 4
.el .IP "\f(CW$surface\fR = Cairo::ImageSurface\->create_for_data ($data, \f(CW$format\fR, \f(CW$width\fR, \f(CW$height\fR, \f(CW$stride\fR)" 4
.IX Item "$surface = Cairo::ImageSurface->create_for_data ($data, $format, $width, $height, $stride)"
.RS 4
.ie n .IP "$data: image data" 4
.el .IP "\f(CW$data:\fR image data" 4
.IX Item "$data: image data"
.ie n .IP "$format: \fICairo::Format\fR" 4
.el .IP "\f(CW$format:\fR \fICairo::Format\fR" 4
.IX Item "$format: Cairo::Format"
.ie n .IP "$width: integer" 4
.el .IP "\f(CW$width:\fR integer" 4
.IX Item "$width: integer"
.ie n .IP "$height: integer" 4
.el .IP "\f(CW$height:\fR integer" 4
.IX Item "$height: integer"
.ie n .IP "$stride: integer" 4
.el .IP "\f(CW$stride:\fR integer" 4
.IX Item "$stride: integer"
.RE
.RS 4
.RE
.ie n .IP "$data = $surface\->get_data [1.2]" 4
.el .IP "\f(CW$data\fR = \f(CW$surface\fR\->get_data [1.2]" 4
.IX Item "$data = $surface->get_data [1.2]"
.ie n .IP "$format = $surface\->get_format [1.2]" 4
.el .IP "\f(CW$format\fR = \f(CW$surface\fR\->get_format [1.2]" 4
.IX Item "$format = $surface->get_format [1.2]"
.ie n .IP "$width = $surface\->get_width" 4
.el .IP "\f(CW$width\fR = \f(CW$surface\fR\->get_width" 4
.IX Item "$width = $surface->get_width"
.ie n .IP "$height = $surface\->get_height" 4
.el .IP "\f(CW$height\fR = \f(CW$surface\fR\->get_height" 4
.IX Item "$height = $surface->get_height"
.ie n .IP "$stride = $surface\->get_stride [1.2]" 4
.el .IP "\f(CW$stride\fR = \f(CW$surface\fR\->get_stride [1.2]" 4
.IX Item "$stride = $surface->get_stride [1.2]"
.ie n .IP "$stride = Cairo::Format::stride_for_width ($format, $width) [1.6]" 4
.el .IP "\f(CW$stride\fR = Cairo::Format::stride_for_width ($format, \f(CW$width\fR) [1.6]" 4
.IX Item "$stride = Cairo::Format::stride_for_width ($format, $width) [1.6]"
.RS 4
.ie n .IP "$format: \fICairo::Format\fR" 4
.el .IP "\f(CW$format:\fR \fICairo::Format\fR" 4
.IX Item "$format: Cairo::Format"
.ie n .IP "$width: integer" 4
.el .IP "\f(CW$width:\fR integer" 4
.IX Item "$width: integer"
.RE
.RS 4
.RE
.PD
.PP
\fI\s-1PDF\s0 Surfaces \*(-- Rendering \s-1PDF\s0 documents\fR
.IX Subsection "PDF Surfaces Rendering PDF documents"
.ie n .IP "$surface = Cairo::PdfSurface\->create ($filename, $width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR = Cairo::PdfSurface\->create ($filename, \f(CW$width_in_points\fR, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface = Cairo::PdfSurface->create ($filename, $width_in_points, $height_in_points) [1.2]"
.RS 4
.PD 0
.ie n .IP "$filename: string" 4
.el .IP "\f(CW$filename:\fR string" 4
.IX Item "$filename: string"
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface = Cairo::PdfSurface\->create_for_stream ($callback, $callback_data, $width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR = Cairo::PdfSurface\->create_for_stream ($callback, \f(CW$callback_data\fR, \f(CW$width_in_points\fR, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface = Cairo::PdfSurface->create_for_stream ($callback, $callback_data, $width_in_points, $height_in_points) [1.2]"
.RS 4
.ie n .IP "$callback: \fICairo::WriteFunc\fR" 4
.el .IP "\f(CW$callback:\fR \fICairo::WriteFunc\fR" 4
.IX Item "$callback: Cairo::WriteFunc"
.ie n .IP "$callback_data: scalar" 4
.el .IP "\f(CW$callback_data:\fR scalar" 4
.IX Item "$callback_data: scalar"
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_size ($width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR\->set_size ($width_in_points, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface->set_size ($width_in_points, $height_in_points) [1.2]"
.RS 4
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface\->restrict_to_version ($version) [1.10]" 4
.el .IP "\f(CW$surface\fR\->restrict_to_version ($version) [1.10]" 4
.IX Item "$surface->restrict_to_version ($version) [1.10]"
.RS 4
.ie n .IP "$version: \fICairo::PdfVersion\fR" 4
.el .IP "\f(CW$version:\fR \fICairo::PdfVersion\fR" 4
.IX Item "$version: Cairo::PdfVersion"
.RE
.RS 4
.RE
.ie n .IP "@versions = Cairo::PdfSurface::get_versions [1.10]" 4
.el .IP "\f(CW@versions\fR = Cairo::PdfSurface::get_versions [1.10]" 4
.IX Item "@versions = Cairo::PdfSurface::get_versions [1.10]"
.ie n .IP "$string = Cairo::PdfSurface::version_to_string ($version) [1.10]" 4
.el .IP "\f(CW$string\fR = Cairo::PdfSurface::version_to_string ($version) [1.10]" 4
.IX Item "$string = Cairo::PdfSurface::version_to_string ($version) [1.10]"
.RS 4
.ie n .IP "$version: \fICairo::PdfVersion\fR" 4
.el .IP "\f(CW$version:\fR \fICairo::PdfVersion\fR" 4
.IX Item "$version: Cairo::PdfVersion"
.RE
.RS 4
.RE
.ie n .IP "$item_id = $surface\->add_outline($parent_id, $name, $attributes, $flags) [1.16]" 4
.el .IP "\f(CW$item_id\fR = \f(CW$surface\fR\->add_outline($parent_id, \f(CW$name\fR, \f(CW$attributes\fR, \f(CW$flags\fR) [1.16]" 4
.IX Item "$item_id = $surface->add_outline($parent_id, $name, $attributes, $flags) [1.16]"
.RS 4
.ie n .IP "$item_id: int, item \s-1ID\s0" 4
.el .IP "\f(CW$item_id:\fR int, item \s-1ID\s0" 4
.IX Item "$item_id: int, item ID"
.ie n .IP "$parent_id: parent item id or Cairo::PdfSurface::OUTLINE_ROOT" 4
.el .IP "\f(CW$parent_id:\fR parent item id or Cairo::PdfSurface::OUTLINE_ROOT" 4
.IX Item "$parent_id: parent item id or Cairo::PdfSurface::OUTLINE_ROOT"
.ie n .IP "$name: string, item display" 4
.el .IP "\f(CW$name:\fR string, item display" 4
.IX Item "$name: string, item display"
.ie n .IP "$attributes: string, item attributes" 4
.el .IP "\f(CW$attributes:\fR string, item attributes" 4
.IX Item "$attributes: string, item attributes"
.ie n .IP "$flags: list reference, item flags" 4
.el .IP "\f(CW$flags:\fR list reference, item flags" 4
.IX Item "$flags: list reference, item flags"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_metadata($name, $value) [1.16]" 4
.el .IP "\f(CW$surface\fR\->set_metadata($name, \f(CW$value\fR) [1.16]" 4
.IX Item "$surface->set_metadata($name, $value) [1.16]"
.RS 4
.ie n .IP "$name: string" 4
.el .IP "\f(CW$name:\fR string" 4
.IX Item "$name: string"
.ie n .IP "$value: string" 4
.el .IP "\f(CW$value:\fR string" 4
.IX Item "$value: string"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_page_label($label) [1.16]" 4
.el .IP "\f(CW$surface\fR\->set_page_label($label) [1.16]" 4
.IX Item "$surface->set_page_label($label) [1.16]"
.RS 4
.ie n .IP "$label: string, page label" 4
.el .IP "\f(CW$label:\fR string, page label" 4
.IX Item "$label: string, page label"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_thumbnail_size($width, $height) [1.16]" 4
.el .IP "\f(CW$surface\fR\->set_thumbnail_size($width, \f(CW$height\fR) [1.16]" 4
.IX Item "$surface->set_thumbnail_size($width, $height) [1.16]"
.RS 4
.ie n .IP "$width: int, thumbnail width" 4
.el .IP "\f(CW$width:\fR int, thumbnail width" 4
.IX Item "$width: int, thumbnail width"
.ie n .IP "$height: int, thumbnail height" 4
.el .IP "\f(CW$height:\fR int, thumbnail height" 4
.IX Item "$height: int, thumbnail height"
.RE
.RS 4
.RE
.PD
.PP
\fI\s-1PNG\s0 Support \*(-- Reading and writing \s-1PNG\s0 images\fR
.IX Subsection "PNG Support Reading and writing PNG images"
.ie n .IP "$surface = Cairo::ImageSurface\->create_from_png ($filename)" 4
.el .IP "\f(CW$surface\fR = Cairo::ImageSurface\->create_from_png ($filename)" 4
.IX Item "$surface = Cairo::ImageSurface->create_from_png ($filename)"
.RS 4
.PD 0
.ie n .IP "$filename: string" 4
.el .IP "\f(CW$filename:\fR string" 4
.IX Item "$filename: string"
.RE
.RS 4
.RE
.ie n .IP "Cairo::ReadFunc: $data = sub { my ($callback_data, $length) = @_; }" 4
.el .IP "Cairo::ReadFunc: \f(CW$data\fR = sub { my ($callback_data, \f(CW$length\fR) = \f(CW@_\fR; }" 4
.IX Item "Cairo::ReadFunc: $data = sub { my ($callback_data, $length) = @_; }"
.RS 4
.ie n .IP "$data: binary image data, of length $length" 4
.el .IP "\f(CW$data:\fR binary image data, of length \f(CW$length\fR" 4
.IX Item "$data: binary image data, of length $length"
.ie n .IP "$callback_data: scalar, user data" 4
.el .IP "\f(CW$callback_data:\fR scalar, user data" 4
.IX Item "$callback_data: scalar, user data"
.ie n .IP "$length: integer, bytes to read" 4
.el .IP "\f(CW$length:\fR integer, bytes to read" 4
.IX Item "$length: integer, bytes to read"
.RE
.RS 4
.RE
.ie n .IP "$surface = Cairo::ImageSurface\->create_from_png_stream ($callback, $callback_data)" 4
.el .IP "\f(CW$surface\fR = Cairo::ImageSurface\->create_from_png_stream ($callback, \f(CW$callback_data\fR)" 4
.IX Item "$surface = Cairo::ImageSurface->create_from_png_stream ($callback, $callback_data)"
.RS 4
.ie n .IP "$callback: \fICairo::ReadFunc\fR" 4
.el .IP "\f(CW$callback:\fR \fICairo::ReadFunc\fR" 4
.IX Item "$callback: Cairo::ReadFunc"
.ie n .IP "$callback_data: scalar" 4
.el .IP "\f(CW$callback_data:\fR scalar" 4
.IX Item "$callback_data: scalar"
.RE
.RS 4
.RE
.ie n .IP "$status = $surface\->write_to_png ($filename)" 4
.el .IP "\f(CW$status\fR = \f(CW$surface\fR\->write_to_png ($filename)" 4
.IX Item "$status = $surface->write_to_png ($filename)"
.RS 4
.ie n .IP "$filename: string" 4
.el .IP "\f(CW$filename:\fR string" 4
.IX Item "$filename: string"
.RE
.RS 4
.RE
.ie n .IP "Cairo::WriteFunc: sub { my ($callback_data, $data) = @_; }" 4
.el .IP "Cairo::WriteFunc: sub { my ($callback_data, \f(CW$data\fR) = \f(CW@_\fR; }" 4
.IX Item "Cairo::WriteFunc: sub { my ($callback_data, $data) = @_; }"
.RS 4
.ie n .IP "$callback_data: scalar, user data" 4
.el .IP "\f(CW$callback_data:\fR scalar, user data" 4
.IX Item "$callback_data: scalar, user data"
.ie n .IP "$data: binary image data, to be written" 4
.el .IP "\f(CW$data:\fR binary image data, to be written" 4
.IX Item "$data: binary image data, to be written"
.RE
.RS 4
.RE
.ie n .IP "$status = $surface\->write_to_png_stream ($callback, $callback_data)" 4
.el .IP "\f(CW$status\fR = \f(CW$surface\fR\->write_to_png_stream ($callback, \f(CW$callback_data\fR)" 4
.IX Item "$status = $surface->write_to_png_stream ($callback, $callback_data)"
.RS 4
.ie n .IP "$callback: \fICairo::WriteFunc\fR" 4
.el .IP "\f(CW$callback:\fR \fICairo::WriteFunc\fR" 4
.IX Item "$callback: Cairo::WriteFunc"
.ie n .IP "$callback_data: scalar" 4
.el .IP "\f(CW$callback_data:\fR scalar" 4
.IX Item "$callback_data: scalar"
.RE
.RS 4
.RE
.PD
.PP
\fIPostScript Surfaces \*(-- Rendering PostScript documents\fR
.IX Subsection "PostScript Surfaces Rendering PostScript documents"
.ie n .IP "$surface = Cairo::PsSurface\->create ($filename, $width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR = Cairo::PsSurface\->create ($filename, \f(CW$width_in_points\fR, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface = Cairo::PsSurface->create ($filename, $width_in_points, $height_in_points) [1.2]"
.RS 4
.PD 0
.ie n .IP "$filename: string" 4
.el .IP "\f(CW$filename:\fR string" 4
.IX Item "$filename: string"
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface = Cairo::PsSurface\->create_for_stream ($callback, $callback_data, $width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR = Cairo::PsSurface\->create_for_stream ($callback, \f(CW$callback_data\fR, \f(CW$width_in_points\fR, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface = Cairo::PsSurface->create_for_stream ($callback, $callback_data, $width_in_points, $height_in_points) [1.2]"
.RS 4
.ie n .IP "$callback: \fICairo::WriteFunc\fR" 4
.el .IP "\f(CW$callback:\fR \fICairo::WriteFunc\fR" 4
.IX Item "$callback: Cairo::WriteFunc"
.ie n .IP "$callback_data: scalar" 4
.el .IP "\f(CW$callback_data:\fR scalar" 4
.IX Item "$callback_data: scalar"
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_size ($width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR\->set_size ($width_in_points, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface->set_size ($width_in_points, $height_in_points) [1.2]"
.RS 4
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface\->dsc_begin_setup [1.2]" 4
.el .IP "\f(CW$surface\fR\->dsc_begin_setup [1.2]" 4
.IX Item "$surface->dsc_begin_setup [1.2]"
.ie n .IP "$surface\->dsc_begin_page_setup [1.2]" 4
.el .IP "\f(CW$surface\fR\->dsc_begin_page_setup [1.2]" 4
.IX Item "$surface->dsc_begin_page_setup [1.2]"
.ie n .IP "$surface\->dsc_comment ($comment) [1.2]" 4
.el .IP "\f(CW$surface\fR\->dsc_comment ($comment) [1.2]" 4
.IX Item "$surface->dsc_comment ($comment) [1.2]"
.RS 4
.ie n .IP "$comment: string" 4
.el .IP "\f(CW$comment:\fR string" 4
.IX Item "$comment: string"
.RE
.RS 4
.RE
.ie n .IP "$surface\->restrict_to_level ($level) [1.6]" 4
.el .IP "\f(CW$surface\fR\->restrict_to_level ($level) [1.6]" 4
.IX Item "$surface->restrict_to_level ($level) [1.6]"
.RS 4
.ie n .IP "$level: \fICairo::PsLevel\fR" 4
.el .IP "\f(CW$level:\fR \fICairo::PsLevel\fR" 4
.IX Item "$level: Cairo::PsLevel"
.RE
.RS 4
.RE
.ie n .IP "@levels = Cairo::PsSurface::get_levels [1.6]" 4
.el .IP "\f(CW@levels\fR = Cairo::PsSurface::get_levels [1.6]" 4
.IX Item "@levels = Cairo::PsSurface::get_levels [1.6]"
.ie n .IP "$string = Cairo::PsSurface::level_to_string ($level) [1.6]" 4
.el .IP "\f(CW$string\fR = Cairo::PsSurface::level_to_string ($level) [1.6]" 4
.IX Item "$string = Cairo::PsSurface::level_to_string ($level) [1.6]"
.RS 4
.ie n .IP "$level: \fICairo::PsLevel\fR" 4
.el .IP "\f(CW$level:\fR \fICairo::PsLevel\fR" 4
.IX Item "$level: Cairo::PsLevel"
.RE
.RS 4
.RE
.ie n .IP "$surface\->set_eps ($eps) [1.6]" 4
.el .IP "\f(CW$surface\fR\->set_eps ($eps) [1.6]" 4
.IX Item "$surface->set_eps ($eps) [1.6]"
.RS 4
.ie n .IP "$eps: boolean" 4
.el .IP "\f(CW$eps:\fR boolean" 4
.IX Item "$eps: boolean"
.RE
.RS 4
.RE
.ie n .IP "$eps = $surface\->get_eps [1.6]" 4
.el .IP "\f(CW$eps\fR = \f(CW$surface\fR\->get_eps [1.6]" 4
.IX Item "$eps = $surface->get_eps [1.6]"
.PD
.PP
\fIRecording Surfaces \*(-- Records all drawing operations\fR
.IX Subsection "Recording Surfaces Records all drawing operations"
.ie n .IP "$surface = Cairo::RecordingSurface\->create ($content, $extents) [1.10]" 4
.el .IP "\f(CW$surface\fR = Cairo::RecordingSurface\->create ($content, \f(CW$extents\fR) [1.10]" 4
.IX Item "$surface = Cairo::RecordingSurface->create ($content, $extents) [1.10]"
.RS 4
.PD 0
.ie n .IP "$content: \fICairo::Content\fR" 4
.el .IP "\f(CW$content:\fR \fICairo::Content\fR" 4
.IX Item "$content: Cairo::Content"
.ie n .IP "$extents: \fICairo::Rectangle\fR" 4
.el .IP "\f(CW$extents:\fR \fICairo::Rectangle\fR" 4
.IX Item "$extents: Cairo::Rectangle"
.RE
.RS 4
.RE
.ie n .IP "($x0, $y0, $width, $height) = $surface\->ink_extents [1.10]" 4
.el .IP "($x0, \f(CW$y0\fR, \f(CW$width\fR, \f(CW$height\fR) = \f(CW$surface\fR\->ink_extents [1.10]" 4
.IX Item "($x0, $y0, $width, $height) = $surface->ink_extents [1.10]"
.ie n .IP "$extents_ref = $surface\->get_extents [1.12]" 4
.el .IP "\f(CW$extents_ref\fR = \f(CW$surface\fR\->get_extents [1.12]" 4
.IX Item "$extents_ref = $surface->get_extents [1.12]"
.RS 4
.ie n .IP "$extents_ref: \fICairo::Rectangle\fR reference" 4
.el .IP "\f(CW$extents_ref:\fR \fICairo::Rectangle\fR reference" 4
.IX Item "$extents_ref: Cairo::Rectangle reference"
.RE
.RS 4
.RE
.PD
.PP
\fI\s-1SVG\s0 Surfaces \*(-- Rendering \s-1SVG\s0 documents\fR
.IX Subsection "SVG Surfaces Rendering SVG documents"
.ie n .IP "$surface = Cairo::SvgSurface\->create ($filename, $width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR = Cairo::SvgSurface\->create ($filename, \f(CW$width_in_points\fR, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface = Cairo::SvgSurface->create ($filename, $width_in_points, $height_in_points) [1.2]"
.RS 4
.PD 0
.ie n .IP "$filename: string" 4
.el .IP "\f(CW$filename:\fR string" 4
.IX Item "$filename: string"
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface = Cairo::SvgSurface\->create_for_stream ($callback, $callback_data, $width_in_points, $height_in_points) [1.2]" 4
.el .IP "\f(CW$surface\fR = Cairo::SvgSurface\->create_for_stream ($callback, \f(CW$callback_data\fR, \f(CW$width_in_points\fR, \f(CW$height_in_points\fR) [1.2]" 4
.IX Item "$surface = Cairo::SvgSurface->create_for_stream ($callback, $callback_data, $width_in_points, $height_in_points) [1.2]"
.RS 4
.ie n .IP "$callback: \fICairo::WriteFunc\fR" 4
.el .IP "\f(CW$callback:\fR \fICairo::WriteFunc\fR" 4
.IX Item "$callback: Cairo::WriteFunc"
.ie n .IP "$callback_data: scalar" 4
.el .IP "\f(CW$callback_data:\fR scalar" 4
.IX Item "$callback_data: scalar"
.ie n .IP "$width_in_points: double" 4
.el .IP "\f(CW$width_in_points:\fR double" 4
.IX Item "$width_in_points: double"
.ie n .IP "$height_in_points: double" 4
.el .IP "\f(CW$height_in_points:\fR double" 4
.IX Item "$height_in_points: double"
.RE
.RS 4
.RE
.ie n .IP "$surface\->restrict_to_version ($version) [1.2]" 4
.el .IP "\f(CW$surface\fR\->restrict_to_version ($version) [1.2]" 4
.IX Item "$surface->restrict_to_version ($version) [1.2]"
.RS 4
.ie n .IP "$version: \fICairo::SvgVersion\fR" 4
.el .IP "\f(CW$version:\fR \fICairo::SvgVersion\fR" 4
.IX Item "$version: Cairo::SvgVersion"
.RE
.RS 4
.RE
.ie n .IP "@versions = Cairo::SvgSurface::get_versions [1.2]" 4
.el .IP "\f(CW@versions\fR = Cairo::SvgSurface::get_versions [1.2]" 4
.IX Item "@versions = Cairo::SvgSurface::get_versions [1.2]"
.ie n .IP "$string = Cairo::SvgSurface::version_to_string ($version) [1.2]" 4
.el .IP "\f(CW$string\fR = Cairo::SvgSurface::version_to_string ($version) [1.2]" 4
.IX Item "$string = Cairo::SvgSurface::version_to_string ($version) [1.2]"
.RS 4
.ie n .IP "$version: \fICairo::SvgVersion\fR" 4
.el .IP "\f(CW$version:\fR \fICairo::SvgVersion\fR" 4
.IX Item "$version: Cairo::SvgVersion"
.RE
.RS 4
.RE
.PD
.SS "Utilities"
.IX Subsection "Utilities"
\fIVersion Information \*(-- Run-time and compile-time version checks.\fR
.IX Subsection "Version Information Run-time and compile-time version checks."
.ie n .IP "$version_code = Cairo\->lib_version" 4
.el .IP "\f(CW$version_code\fR = Cairo\->lib_version" 4
.IX Item "$version_code = Cairo->lib_version"
.PD 0
.ie n .IP "$version_string = Cairo\->lib_version_string" 4
.el .IP "\f(CW$version_string\fR = Cairo\->lib_version_string" 4
.IX Item "$version_string = Cairo->lib_version_string"
.PD
These two functions return the version of libcairo that the program is
currently running against.
.ie n .IP "$version_code = Cairo\->\s-1LIB_VERSION\s0" 4
.el .IP "\f(CW$version_code\fR = Cairo\->\s-1LIB_VERSION\s0" 4
.IX Item "$version_code = Cairo->LIB_VERSION"
Returns the version of libcairo that Cairo was compiled against.
.ie n .IP "$version_code = Cairo\->\s-1LIB_VERSION_ENCODE\s0 ($major, $minor, $micro)" 4
.el .IP "\f(CW$version_code\fR = Cairo\->\s-1LIB_VERSION_ENCODE\s0 ($major, \f(CW$minor\fR, \f(CW$micro\fR)" 4
.IX Item "$version_code = Cairo->LIB_VERSION_ENCODE ($major, $minor, $micro)"
.RS 4
.PD 0
.ie n .IP "$major: integer" 4
.el .IP "\f(CW$major:\fR integer" 4
.IX Item "$major: integer"
.ie n .IP "$minor: integer" 4
.el .IP "\f(CW$minor:\fR integer" 4
.IX Item "$minor: integer"
.ie n .IP "$micro: integer" 4
.el .IP "\f(CW$micro:\fR integer" 4
.IX Item "$micro: integer"
.RE
.RS 4
.PD
.Sp
Encodes the version \f(CW\*(C`$major.$minor.$micro\*(C'\fR as an integer suitable for
comparison against \f(CW\*(C`Cairo\->lib_version\*(C'\fR and \f(CW\*(C`Cairo\->LIB_VERSION\*(C'\fR.
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://cairographics.org/documentation>" 4
.IX Item "<http://cairographics.org/documentation>"
Lists many available resources including tutorials and examples
.IP "<http://cairographics.org/manual/>" 4
.IX Item "<http://cairographics.org/manual/>"
Contains the reference manual
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "Ross McFarland <rwmcfa1 at neces dot com>" 4
.IX Item "Ross McFarland <rwmcfa1 at neces dot com>"
.PD 0
.IP "Torsten Schoenfeld <kaffeetisch at gmx dot de>" 4
.IX Item "Torsten Schoenfeld <kaffeetisch at gmx dot de>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2004\-2013 by the cairo perl team
