.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Vendor 3perl"
.TH Dpkg::Vendor 3perl "2023-05-11" "1.21.22" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Vendor \- get access to some vendor specific information
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The files in \f(CW$Dpkg::CONFDIR\fR/origins/ can provide information about various
vendors who are providing Debian packages. Currently those files look like
this:
.PP
.Vb 3
\&  Vendor: Debian
\&  Vendor\-URL: https://www.debian.org/
\&  Bugs: debbugs://bugs.debian.org
.Ve
.PP
If the vendor derives from another vendor, the file should document
the relationship by listing the base distribution in the Parent field:
.PP
.Vb 1
\&  Parent: Debian
.Ve
.PP
The file should be named according to the vendor name. The usual convention
is to name the vendor file using the vendor name in all lowercase, but some
variation is permitted. Namely, spaces are mapped to dashes ('\-'), and the
file can have the same casing as the Vendor field, or it can be capitalized.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "$dir = \fBget_vendor_dir()\fR" 4
.el .IP "\f(CW$dir\fR = \fBget_vendor_dir()\fR" 4
.IX Item "$dir = get_vendor_dir()"
Returns the current dpkg origins directory name, where the vendor files
are stored.
.ie n .IP "$fields = get_vendor_info($name)" 4
.el .IP "\f(CW$fields\fR = get_vendor_info($name)" 4
.IX Item "$fields = get_vendor_info($name)"
Returns a Dpkg::Control object with the information parsed from the
corresponding vendor file in \f(CW$Dpkg::CONFDIR\fR/origins/. If \f(CW$name\fR is omitted,
it will use \f(CW$Dpkg::CONFDIR\fR/origins/default which is supposed to be a symlink
to the vendor of the currently installed operating system. Returns undef
if there's no file for the given vendor.
.ie n .IP "$name = get_vendor_file($name)" 4
.el .IP "\f(CW$name\fR = get_vendor_file($name)" 4
.IX Item "$name = get_vendor_file($name)"
Check if there's a file for the given vendor and returns its
name.
.Sp
The vendor filename will be derived from the vendor name, by replacing any
number of non-alphanumeric characters (that is \fB[^A\-Za\-z0\-9]\fR) into "\fB\-\fR",
then the resulting name will be tried in sequence by lower-casing it,
keeping it as is, lower-casing then capitalizing it, and capitalizing it.
.Sp
In addition, for historical and backwards compatibility, the name will
be tried keeping it as is without non-alphanumeric characters remapping,
then the resulting name will be tried in sequence by lower-casing it,
keeping it as is, lower-casing then capitalizing it, and capitalizing it.
And finally the name will be tried by replacing only spaces to "\fB\-\fR",
then the resulting name will be tried in sequence by lower-casing it,
keeping it as is, lower-casing then capitalizing it, and capitalizing it.
.Sp
But these backwards compatible name lookups will be removed during
the dpkg 1.22.x release cycle.
.ie n .IP "$name = \fBget_current_vendor()\fR" 4
.el .IP "\f(CW$name\fR = \fBget_current_vendor()\fR" 4
.IX Item "$name = get_current_vendor()"
Returns the name of the current vendor. If \s-1DEB_VENDOR\s0 is set, it uses
that first, otherwise it falls back to parsing \f(CW$Dpkg::CONFDIR\fR/origins/default.
If that file doesn't exist, it returns undef.
.ie n .IP "$object = get_vendor_object($name)" 4
.el .IP "\f(CW$object\fR = get_vendor_object($name)" 4
.IX Item "$object = get_vendor_object($name)"
Return the Dpkg::Vendor::* object of the corresponding vendor.
If \f(CW$name\fR is omitted, return the object of the current vendor.
If no vendor can be identified, then return the Dpkg::Vendor::Default
object.
.Sp
The module name will be derived from the vendor name, by splitting parts
around groups of non alphanumeric character (that is \fB[^A\-Za\-z0\-9]\fR)
separators, by either capitalizing or lower-casing and capitalizing each part
and then joining them without the separators. So the expected casing is based
on the one from the \fBVendor\fR field in the \fIorigins\fR file.
.Sp
In addition, for historical and backwards compatibility, the module name
will also be looked up without non-alphanumeric character stripping, by
capitalizing, lower-casing then capitalizing, as-is or lower-casing.
But these name lookups will be removed during the 1.22.x release cycle.
.ie n .IP "run_vendor_hook($hookid, @params)" 4
.el .IP "run_vendor_hook($hookid, \f(CW@params\fR)" 4
.IX Item "run_vendor_hook($hookid, @params)"
Run a hook implemented by the current vendor object.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.02 (dpkg 1.21.10)"
.IX Subsection "Version 1.02 (dpkg 1.21.10)"
Deprecated behavior: \fBget_vendor_file()\fR loading vendor files with no special
characters remapping. \fBget_vendor_object()\fR loading vendor module names with
no special character stripping.
.SS "Version 1.01 (dpkg 1.17.0)"
.IX Subsection "Version 1.01 (dpkg 1.17.0)"
New function: \fBget_vendor_dir()\fR.
.SS "Version 1.00 (dpkg 1.16.1)"
.IX Subsection "Version 1.00 (dpkg 1.16.1)"
Mark the module as public.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBdeb\-origin\fR\|(5).
