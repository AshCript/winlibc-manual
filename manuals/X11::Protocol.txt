.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Protocol 3pm"
.TH Protocol 3pm "2022-10-13" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X11::Protocol \- Perl module for the X Window System Protocol, version 11
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use X11::Protocol;
\&  $x = X11::Protocol\->new();
\&  $win = $x\->new_rsrc;
\&  $x\->CreateWindow($win, $x\->root, \*(AqInputOutput\*(Aq,
\&                   $x\->root_depth, \*(AqCopyFromParent\*(Aq,
\&                   ($x_coord, $y_coord), $width,
\&                   $height, $border_w);  
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
X11::Protocol is a client-side interface to the X11 Protocol (see X(1) for
information about X11), allowing perl programs to display windows and
graphics on X11 servers.
.PP
A full description of the protocol is beyond the scope of this documentation;
for complete information, see the \fIX Window System Protocol, X Version 11\fR,
available as Postscript or *roff source from \f(CW\*(C`ftp://ftp.x.org\*(C'\fR, or
\&\fIVolume 0: X Protocol Reference Manual\fR of O'Reilly & Associates's series of
books about X (\s-1ISBN 1\-56592\-083\-X,\s0 \f(CW\*(C`http://www.oreilly.com\*(C'\fR), which contains
most of the same information.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
``The protocol contains many management mechanisms that are
not intended for normal applications.  Not all mechanisms
are needed to build a particular user interface.  It is
important to keep in mind that the protocol is intended to
provide mechanism, not policy.'' \*(-- Robert W. Scheifler
.SH "BASIC METHODS"
.IX Header "BASIC METHODS"
.SS "new"
.IX Subsection "new"
.Vb 5
\&  $x = X11::Protocol\->new();
\&  $x = X11::Protocol\->new($display_name);
\&  $x = X11::Protocol\->new($connection);
\&  $x = X11::Protocol\->new($display_name, [$auth_type, $auth_data]);
\&  $x = X11::Protocol\->new($connection, [$auth_type, $auth_data]);
.Ve
.PP
Open a connection to a server. \f(CW$display_name\fR should be an X display
name, of the form 'host:display_num.screen_num'; if no arguments are
supplied, the contents of the \s-1DISPLAY\s0 environment variable are
used. Alternatively, a pre-opened connection, of one of the
X11::Protocol::Connection classes (see
X11::Protocol::Connection,
X11::Protocol::Connection::FileHandle,
X11::Protocol::Connection::Socket,
X11::Protocol::Connection::UNIXFH,
X11::Protocol::Connection::INETFH,
X11::Protocol::Connection::UNIXSocket,
X11::Protocol::Connection::INETSocket) can be given. The
authorization data is obtained using X11::Auth or the second
argument. If the display is specified by \f(CW$display_name\fR, rather than
\&\f(CW$connection\fR, a \fBchoose_screen()\fR is also performed, defaulting to screen
0 if the '.screen_num' of the display name is not present.  Returns
the new protocol object.
.SS "new_rsrc"
.IX Subsection "new_rsrc"
.Vb 1
\&  $x\->new_rsrc;
.Ve
.PP
Returns a new resource identifier. A unique resource \s-1ID\s0 is required
for every object that the server creates on behalf of the client:
windows, fonts, cursors, etc. (IDs are chosen by the client instead of
the server for efficiency \*(-- the client doesn't have to wait for the
server to acknowledge the creation before starting to use the object).
.PP
Note that the total number of available resource IDs, while large, is
finite.  Beginning from the establishment of a connection, resource
IDs are allocated sequentially from a range whose size is server
dependent (commonly 2**21, about 2 million).  If this limit is reached
and the server does not support the \s-1XC_MISC\s0 extension, subsequent
calls to new_rsrc will croak.  If the server does support this
extension, the module will attempt to request a new range of free IDs
from the server.  This should allow the program to continue, but it is
an imperfect solution, as over time the set of available IDs may
fragment, requiring increasingly frequent round-trip range requests
from the server.  For long-running programs, the best approach may be
to keep track of free IDs as resources are destroyed.  In the current
version, however, no special support is provided for this.
.SS "handle_input"
.IX Subsection "handle_input"
.Vb 1
\&  $x\->handle_input;
.Ve
.PP
Get one chunk of information from the server, and do something with it. If it's
an error, handle it using the protocol object's handler ('error_handler'
\&\*(-- default is kill the program with an explanatory message). If it's an event,
pass it to the chosen event handler, or put it in a queue if the handler is
\&'queue'. If it's a reply to a request, save using the object's 'replies' hash
for further processing.
.SS "atom_name"
.IX Subsection "atom_name"
.Vb 1
\&  $name = $x\->atom_name($atom);
.Ve
.PP
Return the string corresponding to the atom \f(CW$atom\fR. This is similar to the
GetAtomName request, but caches the result for efficiency.
.SS "atom"
.IX Subsection "atom"
.Vb 1
\&  $atom = $x\->atom($name);
.Ve
.PP
The inverse operation; Return the (numeric) atom corresponding to \f(CW$name\fR.
This is similar to the InternAtom request, but caches the result.
.SS "choose_screen"
.IX Subsection "choose_screen"
.Vb 1
\&  $x\->choose_screen($screen_num);
.Ve
.PP
Indicate that you prefer to use a particular screen of the display. Per-screen
information, such as 'root', 'width_in_pixels', and 'white_pixel' will be
made available as
.PP
.Vb 1
\&  $x\->{\*(Aqroot\*(Aq}
.Ve
.PP
instead of
.PP
.Vb 1
\&  $x\->{\*(Aqscreens\*(Aq}[$screen_num]{\*(Aqroot\*(Aq}
.Ve
.SH "SYMBOLIC CONSTANTS"
.IX Header "SYMBOLIC CONSTANTS"
Generally, symbolic constants used by the protocol, like 'CopyFromParent'
or 'PieSlice' are passed to methods as strings, and
converted into numbers by the module.  Their names are the same as
those in the protocol specification, including capitalization, but
with hyphens ('\-') changed to underscores ('_') to look more
perl-ish. If you want to do the conversion yourself for some reason,
the following methods are available:
.SS "num"
.IX Subsection "num"
.Vb 1
\&  $num = $x\->num($type, $str)
.Ve
.PP
Given a string representing a constant and a string specifying what
type of constant it is, return the corresponding number. \f(CW$type\fR should
be a name like 'VisualClass' or 'GCLineStyle'. If the name is not
recognized, it is returned intact.
.SS "interp"
.IX Subsection "interp"
.Vb 1
\&  $name = $x\->interp($type, $num)
.Ve
.PP
The inverse operation; given a number and string specifying its type, return
a string representing the constant.
.PP
You can disable \fBinterp()\fR and the module's internal interpretation of
numbers by setting \f(CW$x\fR\->{'do_interp'} to zero. Of course, this isn't
very useful, unless you have you own definitions for all the
constants.
.PP
Here is a list of available constant types:
.PP
.Vb 12
\&  AccessMode, AllowEventsMode, AutoRepeatMode, BackingStore,
\&  BitGravity, Bool, ChangePropertyMode, CirculateDirection,
\&  CirculatePlace, Class, ClipRectangleOrdering, CloseDownMode,
\&  ColormapNotifyState, CoordinateMode, CrossingNotifyDetail,
\&  CrossingNotifyMode, DeviceEvent, DrawDirection, Error, EventMask,
\&  Events, FocusDetail, FocusMode, GCArcMode, GCCapStyle, GCFillRule,
\&  GCFillStyle, GCFunction, GCJoinStyle, GCLineStyle, GCSubwindowMode,
\&  GrabStatus, HostChangeMode, HostFamily, ImageFormat,
\&  InputFocusRevertTo, KeyMask, LedMode, MapState, MappingChangeStatus,
\&  MappingNotifyRequest, PointerEvent, PolyShape, PropertyNotifyState,
\&  Request, ScreenSaver, ScreenSaverAction, Significance, SizeClass,
\&  StackMode, SyncMode, VisibilityState, VisualClass, WinGravity
.Ve
.SH "SERVER INFORMATION"
.IX Header "SERVER INFORMATION"
At connection time, the server sends a large amount of information about
itself to the client. This information is stored in the protocol object
for future reference. It can be read directly, like
.PP
.Vb 1
\&  $x\->{\*(Aqrelease_number\*(Aq}
.Ve
.PP
or, for object oriented True Believers, using a method:
.PP
.Vb 1
\&  $x\->release_number
.Ve
.PP
The method method also has a one argument form for setting variables, but
it isn't really useful for some of the more complex structures.
.PP
Here is an example of what the object's information might look like:
.PP
.Vb 10
\&  \*(Aqconnection\*(Aq => X11::Connection::UNIXSocket(0x814526fd),
\&  \*(Aqbyte_order\*(Aq => \*(Aql\*(Aq,
\&  \*(Aqprotocol_major_version\*(Aq => 11,
\&  \*(Aqprotocol_minor_version\*(Aq => 0,
\&  \*(Aqauthorization_protocol_name\*(Aq => \*(AqMIT\-MAGIC\-COOKIE\-1\*(Aq,
\&  \*(Aqrelease_number\*(Aq => 3110,
\&  \*(Aqresource_id_base\*(Aq => 0x1c000002,
\&  \*(Aqmotion_buffer_size\*(Aq => 0,
\&  \*(Aqmaximum_request_length\*(Aq => 65535, # units of 4 bytes
\&  \*(Aqimage_byte_order\*(Aq => \*(AqLeastSiginificant\*(Aq,
\&  \*(Aqbitmap_bit_order\*(Aq => \*(AqLeastSiginificant\*(Aq,
\&  \*(Aqbitmap_scanline_unit\*(Aq => 32,
\&  \*(Aqbitmap_scanline_pad\*(Aq => 32,
\&  \*(Aqmin_keycode\*(Aq => 8,
\&  \*(Aqmax_keycode\*(Aq => 134,
\&  \*(Aqvendor\*(Aq => \*(AqThe XFree86 Project, Inc\*(Aq,
\&  \*(Aqpixmap_formats\*(Aq => {1 => {\*(Aqbits_per_pixel\*(Aq => 1,
\&                             \*(Aqscanline_pad\*(Aq => 32},
\&                       8 => {\*(Aqbits_per_pixel\*(Aq => 8,
\&                             \*(Aqscanline_pad\*(Aq => 32}},
\&  \*(Aqscreens\*(Aq => [{\*(Aqroot\*(Aq => 43, \*(Aqwidth_in_pixels\*(Aq => 800,
\&                 \*(Aqheight_in_pixels\*(Aq => 600,
\&                 \*(Aqwidth_in_millimeters\*(Aq => 271,
\&                 \*(Aqheight_in_millimeters\*(Aq => 203,
\&                 \*(Aqroot_depth\*(Aq => 8,
\&                 \*(Aqroot_visual\*(Aq => 34,
\&                 \*(Aqdefault_colormap\*(Aq => 33,
\&                 \*(Aqwhite_pixel\*(Aq => 0, \*(Aqblack_pixel\*(Aq => 1,
\&                 \*(Aqmin_installed_maps\*(Aq => 1,
\&                 \*(Aqmax_installed_maps\*(Aq => 1,
\&                 \*(Aqbacking_stores\*(Aq => \*(AqAlways\*(Aq,
\&                 \*(Aqsave_unders\*(Aq => 1,
\&                 \*(Aqcurrent_input_masks\*(Aq => 0x58003d,
\&                 \*(Aqallowed_depths\*(Aq =>
\&                    [{\*(Aqdepth\*(Aq => 1, \*(Aqvisuals\*(Aq => []},
\&                     {\*(Aqdepth\*(Aq => 8, \*(Aqvisuals\*(Aq => [
\&                        {\*(Aqvisual_id\*(Aq => 34, \*(Aqblue_mask\*(Aq => 0,
\&                         \*(Aqgreen_mask\*(Aq => 0, \*(Aqred_mask\*(Aq => 0, 
\&                         \*(Aqclass\*(Aq => \*(AqPseudoColor\*(Aq,
\&                         \*(Aqbits_per_rgb_value\*(Aq => 6,
\&                         \*(Aqcolormap_entries\*(Aq => 256},
\&                        {\*(Aqvisual_id\*(Aq => 35, \*(Aqblue_mask\*(Aq => 0xc0,
\&                         \*(Aqgreen_mask\*(Aq => 0x38, \*(Aqred_mask\*(Aq => 0x7, 
\&                         \*(Aqclass\*(Aq => \*(AqDirectColor\*(Aq,
\&                         \*(Aqbits_per_rgb_value\*(Aq => 6,
\&                         \*(Aqcolormap_entries\*(Aq => 8}, ...]}]],
\&  \*(Aqvisuals\*(Aq => {34 => {\*(Aqdepth\*(Aq => 8, \*(Aqclass\*(Aq => \*(AqPseudoColor\*(Aq,
\&                       \*(Aqred_mask\*(Aq => 0, \*(Aqgreen_mask\*(Aq => 0,
\&                       \*(Aqblue_mask\*(Aq=> 0, \*(Aqbits_per_rgb_value\*(Aq => 6,
\&                       \*(Aqcolormap_entries\*(Aq => 256},
\&                35 => {\*(Aqdepth\*(Aq => 8, \*(Aqclass\*(Aq => \*(AqDirectColor\*(Aq,
\&                       \*(Aqred_mask\*(Aq => 0x7, \*(Aqgreen_mask\*(Aq => 0x38,
\&                       \*(Aqblue_mask\*(Aq=> 0xc0, \*(Aqbits_per_rgb_value\*(Aq => 6,
\&                       \*(Aqcolormap_entries\*(Aq => 8}, ...}
\&  \*(Aqerror_handler\*(Aq => &\eX11::Protocol::default_error_handler,
\&  \*(Aqevent_handler\*(Aq => sub {},
\&  \*(Aqdo_interp\*(Aq => 1
.Ve
.SH "REQUESTS"
.IX Header "REQUESTS"
.SS "request"
.IX Subsection "request"
.Vb 3
\&  $x\->request(\*(AqCreateWindow\*(Aq, ...);
\&  $x\->req(\*(AqCreateWindow\*(Aq, ...);
\&  $x\->CreateWindow(...);
.Ve
.PP
Send a protocol request to the server, and get the reply, if any. For
names of and information about individual requests, see below and/or
the protocol reference manual.
.SS "robust_req"
.IX Subsection "robust_req"
.Vb 1
\&  $x\->robust_req(\*(AqCreateWindow\*(Aq, ...);
.Ve
.PP
Like \fBrequest()\fR, but if the server returns an error, return the error
information rather than calling the error handler (which by default
just croaks). If the request succeeds, returns an array reference
containing whatever \fBrequest()\fR would have. Otherwise, returns the error
type, the major and minor opcodes of the failed request, and the extra
error information, if any. Note that even if the request normally
wouldn't have a reply, this method still has to wait for a round-trip
time to see whether an error occurred. If you're concerned about
performance, you should design your error handling to be asynchronous.
.SS "add_reply"
.IX Subsection "add_reply"
.Vb 1
\&  $x\->add_reply($sequence_num, \e$var);
.Ve
.PP
Add a stub for an expected reply to the object's 'replies' hash. When a reply
numbered \f(CW$sequence_num\fR comes, it will be stored in \f(CW$var\fR.
.SS "delete_reply"
.IX Subsection "delete_reply"
.Vb 1
\&  $x\->delete_reply($sequence_num);
.Ve
.PP
Delete the entry in 'replies' for the specified reply. (This should be done
after the reply is received).
.SS "send"
.IX Subsection "send"
.Vb 1
\&  $x\->send(\*(AqCreateWindow\*(Aq, ...);
.Ve
.PP
Send a request, but do not wait for a reply. You must handle the reply, if any,
yourself, using \fBadd_reply()\fR, \fBhandle_input()\fR, \fBdelete_reply()\fR, and
\&\fBunpack_reply()\fR, generally in that order.
.SS "unpack_reply"
.IX Subsection "unpack_reply"
.Vb 1
\&  $x\->unpack_reply(\*(AqGetWindowAttributes\*(Aq, $data);
.Ve
.PP
Interpret the raw reply data \f(CW$data\fR, according to the reply format for the named
request. Returns data in the same format as \f(CW\*(C`request($request_name, ...)\*(C'\fR.
.PP
This section includes only a short calling summary for each request; for
full descriptions, see the protocol standard. Argument order is usually the
same as listed in the spec, but you generally don't have to pass lengths of
strings or arrays, since perl keeps track. Symbolic constants are generally
passed as strings. Most replies are returned as lists, but when there are
many values, a hash is used. Lists usually come last; when there is more than
one, each is passed by reference. In lists of multi-part structures, each
element is a list ref. Parenthesis are inserted in arg lists for clarity,
but are optional. Requests are listed in order by major opcode, so related
requests are usually close together. Replies follow the '=>'.
.PP
.Vb 3
\&  $x\->CreateWindow($wid, $parent, $class, $depth, $visual, ($x, $y),
\&                   $width, $height, $border_width,
\&                   \*(Aqattribute\*(Aq => $value, ...)
\&
\&  $x\->ChangeWindowAttributes($window, \*(Aqattribute\*(Aq => $value, ...)
\&
\&  $x\->GetWindowAttributes($window)
\&  =>
\&  (\*(Aqbacking_store\*(Aq => $backing_store, ...)
.Ve
.PP
This is an example of a return value that is meant to be assigned to a hash.
.PP
.Vb 1
\&  $x\->DestroyWindow($win)
\&
\&  $x\->DestroySubwindows($win)
\&
\&  $x\->ChangeSaveSet($window, $mode)
\&
\&  $x\->ReparentWindow($win, $parent, ($x, $y))
\&
\&  $x\->MapWindow($win)
\&
\&  $x\->MapSubwindows($win)
\&
\&  $x\->UnmapWindow($win)
\&
\&  $x\->UnmapSubwindows($win)
\&
\&  $x\->ConfigureWindow($win, \*(Aqattribute\*(Aq => $value, ...)
\&
\&  $x\->CirculateWindow($win, $direction)
.Ve
.PP
Note that this request actually circulates the subwindows of \f(CW$win\fR,
not the window itself.
.PP
.Vb 3
\&  $x\->GetGeometry($drawable)
\&  =>
\&  (\*(Aqroot\*(Aq => $root, ...)
\&
\&  $x\->QueryTree($win)
\&  =>
\&  ($root, $parent, @kids)
\&
\&  $x\->InternAtom($name, $only_if_exists)
\&  =>
\&  $atom
\&
\&  $x\->GetAtomName($atom)
\&  =>
\&  $name
\&
\&  $x\->ChangeProperty($window, $property, $type, $format, $mode, $data)
\&
\&  $x\->DeleteProperty($win, $atom)
\&
\&  $x\->GetProperty($window, $property, $type, $offset, $length, $delete)
\&  =>
\&  ($value, $type, $format, $bytes_after)
.Ve
.PP
Notice that the value comes first, so you can easily ignore the rest.
.PP
.Vb 3
\&  $x\->ListProperties($window)
\&  =>
\&  (@atoms)
\&
\&  $x\->SetSelectionOwner($selection, $owner, $time)
\&
\&  $x\->GetSelectionOwner($selection)
\&  =>
\&  $owner
\&
\&  $x\->ConvertSelection($selection, $target, $property, $requestor, $time)
\&
\&  $x\->SendEvent($destination, $propagate, $event_mask, $event)
.Ve
.PP
The \f(CW$event\fR argument should be the result of a \fBpack_event()\fR (see \*(L"\s-1EVENTS\*(R"\s0)
.PP
.Vb 5
\&  $x\->GrabPointer($grab_window, $owner_events, $event_mask,
\&                  $pointer_mode, $keyboard_mode, $confine_to,
\&                  $cursor, $time)
\&  =>
\&  $status
\&
\&  $x\->UngrabPointer($time)
\&
\&  $x\->GrabButton($modifiers, $button, $grab_window, $owner_events,
\&                 $event_mask, $pointer_mode, $keyboard_mode,
\&                 $confine_to, $cursor)
\&
\&  $x\->UngrabButton($modifiers, $button, $grab_window)
\&
\&  $x\->ChangeActivePointerGrab($event_mask, $cursor, $time)
\&
\&  $x\->GrabKeyboard($grab_window, $owner_events, $pointer_mode,
\&                   $keyboard_mode, $time)
\&  =>
\&  $status
\&
\&  $x\->UngrabKeyboard($time)
\&
\&  $x\->GrabKey($key, $modifiers, $grab_window, $owner_events,
\&              $pointer_mode, $keyboard_mode)
\&
\&  $x\->UngrabKey($key, $modifiers, $grab_window)
\&
\&  $x\->AllowEvents($mode, $time)
\&
\&  $x\->GrabServer
\&
\&  $x\->UngrabServer
\&
\&  $x\->QueryPointer($window)
\&  =>
\&  (\*(Aqroot\*(Aq => $root, ...)
\&
\&  $x\->GetMotionEvents($start, $stop, $window)
\&  =>
\&  ([$time, ($x, $y)], [$time, ($x, $y)], ...)
\&
\&  $x\->TranslateCoordinates($src_window, $dst_window, $src_x, $src_y)
\&  =>
\&  ($same_screen, $child, $dst_x, $dst_y)
\&
\&  $x\->WarpPointer($src_window, $dst_window, $src_x, $src_y, $src_width,
\&                  $src_height, $dst_x, $dst_y)
\&
\&  $x\->SetInputFocus($focus, $revert_to, $time)
\&
\&  $x\->GetInputFocus
\&  =>
\&  ($focus, $revert_to)
\&
\&  $x\->QueryKeymap
\&  =>
\&  $keys
.Ve
.PP
\&\f(CW$keys\fR is a bit vector, so you should use \fBvec()\fR to read it.
.PP
.Vb 1
\&  $x\->OpenFont($fid, $name)
\&
\&  $x\->CloseFont($font)
\&
\&  $x\->QueryFont($font)
\&  =>
\&  (\*(Aqmin_char_or_byte2\*(Aq => $min_char_or_byte2,
\&   ..., 
\&   \*(Aqmin_bounds\*(Aq =>
\&   [$left_side_bearing, $right_side_bearing, $character_width, $ascent,
\&    $descent, $attributes],
\&   ...,
\&   \*(Aqchar_infos\*(Aq =>
\&   [[$left_side_bearing, $right_side_bearing, $character_width, $ascent,
\&     $descent, $attributes], 
\&    ...], 
\&   \*(Aqproperties\*(Aq => {$prop => $value, ...}
\&   )
\&
\&  $x\->QueryTextExtents($font, $string)
\&  =>
\&  (\*(Aqdraw_direction\*(Aq => $draw_direction, ...)
\&
\&  $x\->ListFonts($pattern, $max_names)
\&  =>
\&  @names
\&
\&  $x\->ListFontsWithInfo($pattern, $max_names)
\&  =>
\&  ({\*(Aqname\*(Aq => $name, ...}, {\*(Aqname\*(Aq => $name, ...}, ...)
.Ve
.PP
The information in each hash is the same as the the information returned by
QueryFont, but without per-character size information. This request is
special in that it is the only request that can have more than one reply.
This means you should probably only use \fBrequest()\fR with it, not \fBsend()\fR, as
the reply counting is complicated. Luckily, you never need this request
anyway, as its function is completely duplicated by other requests.
.PP
.Vb 1
\&  $x\->SetFontPath(@strings)
\&
\&  $x\->GetFontPath
\&  =>
\&  @strings
\&
\&  $x\->CreatePixmap($pixmap, $drawable, $depth, $width, $height)
\&
\&  $x\->FreePixmap($pixmap)
\&
\&  $x\->CreateGC($cid, $drawable, \*(Aqattribute\*(Aq => $value, ...)
\&
\&  $x\->ChangeGC($gc, \*(Aqattribute\*(Aq => $value, ...)
\&
\&  $x\->CopyGC($src, $dest, \*(Aqattribute\*(Aq, \*(Aqattribute\*(Aq, ...)
\&
\&  $x\->SetDashes($gc, $dash_offset, (@dashes))
\&
\&  $x\->SetClipRectangles($gc, ($clip_x_origin, $clip_y_origin),
\&                        $ordering, [$x, $y, $width, $height], ...)
\&
\&  $x\->ClearArea($window, ($x, $y), $width, $height, $exposures)
\&
\&  $x\->CopyArea($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
\&               $width, $height, ($dst_x, $dst_y))
\&
\&  $x\->CopyPlane($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
\&                $width, $height, ($dst_x, $dst_y), $bit_plane)
\&
\&  $x\->PolyPoint($drawable, $gc, $coordinate_mode,
\&                ($x, $y), ($x, $y), ...)
\&
\&  $x\->PolyLine($drawable, $gc, $coordinate_mode,
\&               ($x, $y), ($x, $y), ...)
\&
\&  $x\->PolySegment($drawable, $gc, ($x, $y) => ($x, $y),
\&                  ($x, $y) => ($x, $y), ...)
\&
\&  $x\->PolyRectangle($drawable, $gc,
\&                    [($x, $y), $width, $height], ...)
\&
\&  $x\->PolyArc($drawable, $gc,
\&              [($x, $y), $width, $height, $angle1, $angle2], ...)
\&
\&  $x\->FillPoly($drawable, $gc, $shape, $coordinate_mode,
\&               ($x, $y), ...)
\&
\&  $x\->PolyFillRectangle($drawable, $gc,
\&                        [($x, $y), $width, $height], ...)
\&
\&  $x\->PolyFillArc($drawable, $gc,
\&                  [($x, $y), $width, $height, $angle1, $angle2], ...)
\&
\&  $x\->PutImage($drawable, $gc, $depth, $width, $height,
\&               ($dst_x, $dst_y), $left_pad, $format, $data)
.Ve
.PP
Currently, the module has no code to handle the various bitmap formats that
the server might specify. Therefore, this request will not work portably
without a lot of work.
.PP
.Vb 2
\&  $x\->GetImage($drawable, ($x, $y), $width, $height, $plane_mask,
\&               $format)
\&
\&  $x\->PolyText8($drawable, $gc, ($x, $y),
\&                ($font OR [$delta, $string]), ...)
\&
\&  $x\->PolyText16($drawable, $gc, ($x, $y),
\&                 ($font OR [$delta, $string]), ...)
\&
\&  $x\->ImageText8($drawable, $gc, ($x, $y), $string)
\&
\&  $x\->ImageText16($drawable, $gc, ($x, $y), $string)
\&
\&  $x\->CreateColormap($mid, $visual, $window, $alloc)
\&
\&  $x\->FreeColormap($cmap)
\&
\&  $x\->CopyColormapAndFree($mid, $src_cmap)
\&
\&  $x\->InstallColormap($cmap)
\&
\&  $x\->UninstallColormap($cmap)
\&
\&  $x\->ListInstalledColormaps($window)
\&  =>
\&  @cmaps
\&
\&  $x\->AllocColor($cmap, ($red, $green, $blue))
\&  =>
\&  ($pixel, ($red, $green, $blue))
\&
\&  $x\->AllocNamedColor($cmap, $name)
\&  =>
\&  ($pixel, ($exact_red, $exact_green, $exact_blue),
\&   ($visual_red, $visual_green, $visual_blue))
\&
\&  $x\->AllocColorCells($cmap, $colors, $planes, $contiguous)
\&  =>
\&  ([@pixels], [@masks])
\&
\&  $x\->AllocColorPlanes($cmap, $colors, ($reds, $greens, $blues),
\&                       $contiguous)
\&  =>
\&  (($red_mask, $green_mask, $blue_mask), @pixels)
\&
\&  $x\->FreeColors($cmap, $plane_mask, @pixels)
\&
\&  $x\->StoreColors($cmap, [$pixel, $red, $green, $blue, $do_mask], ...)
.Ve
.PP
The 1, 2, and 4 bits in \f(CW$do_mask\fR are do-red, do-green, and
do-blue. \f(CW$do_mask\fR can be omitted, defaulting to 7, the usual case \*(--
change the whole color.
.PP
.Vb 1
\&  $x\->StoreNamedColor($cmap, $pixel, $name, $do_mask)
.Ve
.PP
\&\f(CW$do_mask\fR has the same interpretation as above, but is mandatory.
.PP
.Vb 3
\&  $x\->QueryColors($cmap, @pixels)
\&  =>
\&  ([$red, $green, $blue], ...)
\&
\&  $x\->LookupColor($cmap, $name)
\&  =>
\&  (($exact_red, $exact_green, $exact_blue),
\&   ($visual_red, $visual_green, $visual_blue)) 
\&
\&  $x\->CreateCursor($cid, $source, $mask,
\&                   ($fore_red, $fore_green, $fore_blue),
\&                   ($back_red, $back_green, $back_blue),
\&                   ($x, $y))
\&
\&  $x\->CreateGlyphCursor($cid, $source_font, $mask_font,
\&                        $source_char, $mask_char,
\&                        ($fore_red, $fore_green, $fore_blue),
\&                        ($back_red, $back_green, $back_blue))
\&                        
\&  $x\->FreeCursor($cursor)
\&
\&  $x\->RecolorCursor($cursor, ($fore_red, $fore_green, $fore_blue),
\&                    ($back_red, $back_green, $back_blue))
\&
\&  $x\->QueryBestSize($class, $drawable, $width, $height)
\&  =>
\&  ($width, $height)
\&
\&  $x\->QueryExtension($name)
\&  =>
\&  ($major_opcode, $first_event, $first_error)
.Ve
.PP
If the extension is not present, an empty list is returned.
.PP
.Vb 3
\&  $x\->ListExtensions
\&  =>
\&  (@names)
\&
\&  $x\->ChangeKeyboardMapping($first_keycode, $keysysms_per_keycode,
\&                            @keysyms)
\&
\&  $x\->GetKeyboardMapping($first_keycode, $count)
\&  =>
\&  ($keysysms_per_keycode, [$keysym, ...], [$keysym, ...], ...)
\&
\&  $x\->ChangeKeyboardControl(\*(Aqattribute\*(Aq => $value, ...)
\&
\&  $x\->GetKeyboardControl
\&  =>
\&  (\*(Aqglobal_auto_repeat\*(Aq => $global_auto_repeat, ...)
\&
\&  $x\->Bell($percent)
\&
\&  $x\->ChangePointerControl($do_acceleration, $do_threshold,
\&                           $acceleration_numerator,
\&                           $acceleration_denominator, $threshold)
\&
\&  $x\->GetPointerControl
\&  =>
\&  ($acceleration_numerator, $acceleration_denominator, $threshold)
\&
\&  $x\->SetScreenSaver($timeout, $interval, $prefer_blanking,
\&                     $allow_exposures)
\&
\&  $x\->GetScreenSaver
\&  =>
\&  ($timeout, $interval, $prefer_blanking, $allow_exposures)
\&
\&  $x\->ChangeHosts($mode, $host_family, $host_address) 
\&
\&  $x\->ListHosts
\&  =>
\&  ($mode, [$family, $host], ...)
\&
\&  $x\->SetAccessControl($mode)
\&
\&  $x\->SetCloseDownMode($mode)
\&
\&  $x\->KillClient($resource)
\&
\&  $x\->RotateProperties($win, $delta, @props)
\&
\&  $x\->ForceScreenSaver($mode)
\&
\&  $x\->SetPointerMapping(@map)
\&  =>
\&  $status
\&
\&  $x\->GetPointerMapping
\&  =>
\&  @map
\&
\&  $x\->SetModifierMapping(@keycodes)
\&  =>
\&  $status
\&
\&  $x\->GetModiferMapping
\&  =>
\&  @keycodes
\&
\&  $x\->NoOperation($length)
.Ve
.PP
\&\f(CW$length\fR specifies the length of the entire useless request, in four byte units,
and is optional.
.SH "EVENTS"
.IX Header "EVENTS"
To receive events, first set the 'event_mask' attribute on a window to
indicate what types of events you desire (see
\&\*(L"pack_event_mask\*(R"). Then, set the protocol object's 'event_handler'
to a subroutine reference that will handle the events. Alternatively,
set 'event_handler' to 'queue', and retrieve events using
\&\fBdequeue_event()\fR or \fBnext_event()\fR. In both cases, events are returned as
a hash. For instance, a typical MotionNotify event might look like
this:
.PP
.Vb 5
\&  %event = (\*(Aqname\*(Aq => \*(AqMotionNotify\*(Aq, \*(Aqsequence_number\*(Aq => 12,
\&            \*(Aqstate\*(Aq => 0, \*(Aqevent\*(Aq => 58720256, \*(Aqroot\*(Aq => 43,
\&            \*(Aqchild\*(Aq => None, \*(Aqsame_screen\*(Aq => 1, \*(Aqtime\*(Aq => 966080746,
\&            \*(Aqdetail\*(Aq => \*(AqNormal\*(Aq, \*(Aqevent_x\*(Aq => 10, \*(Aqevent_y\*(Aq => 3,
\&            \*(Aqcode\*(Aq => 6, \*(Aqroot_x\*(Aq => 319, \*(Aqroot_y\*(Aq => 235)
.Ve
.SS "pack_event_mask"
.IX Subsection "pack_event_mask"
.Vb 1
\&  $mask = $x\->pack_event_mask(\*(AqButtonPress\*(Aq, \*(AqKeyPress\*(Aq, \*(AqExposure\*(Aq);
.Ve
.PP
Make an event mask (suitable as the 'event_mask' of a window) from a list
of strings specifying event types.
.SS "unpack_event_mask"
.IX Subsection "unpack_event_mask"
.Vb 1
\&  @event_types = $x\->unpack_event_mask($mask);
.Ve
.PP
The inverse operation; convert an event mask obtained from the server into a
list of names of event categories.
.SS "dequeue_event"
.IX Subsection "dequeue_event"
.Vb 1
\&  %event = $x\->dequeue_event;
.Ve
.PP
If there is an event waiting in the queue, return it.
.SS "next_event"
.IX Subsection "next_event"
.Vb 1
\&  %event = $x\->next_event;
.Ve
.PP
Like Xlib's \fBXNextEvent()\fR, this function is equivalent to
.PP
.Vb 1
\&  $x\->handle_input until %event = dequeue_event;
.Ve
.SS "pack_event"
.IX Subsection "pack_event"
.Vb 1
\&  $data = $x\->pack_event(%event);
.Ve
.PP
Given an event in hash form, pack it into a string. This is only useful as
an argument to \fBSendEvent()\fR.
.SS "unpack_event"
.IX Subsection "unpack_event"
.Vb 1
\&  %event = $x\->unpack_event($data);
.Ve
.PP
The inverse operation; given the raw data for an event (32 bytes), unpack it
into hash form. Normally, this is done automatically.
.SH "EXTENSIONS"
.IX Header "EXTENSIONS"
Protocol extensions add new requests, event types, and error types to
the protocol. Support for them is compartmentalized in modules in the
X11::Protocol::Ext:: hierarchy. For an example, see
X11::Protocol::Ext::SHAPE. You can tell if the module has loaded an
extension by looking at
.PP
.Vb 1
\&  $x\->{\*(Aqext\*(Aq}{$extension_name}
.Ve
.PP
If the extension has been initialized, this value will be an array reference,
[$major_request_number, \f(CW$first_event_number\fR, \f(CW$first_error_number\fR, \f(CW$obj\fR], where
\&\f(CW$obj\fR is an object containing information private to the extension.
.SS "init_extension"
.IX Subsection "init_extension"
.Vb 1
\&  $x\->init_extension($name);
.Ve
.PP
Initialize an extension: query the server to find the extension's request
number, then load the corresponding module. Returns 0 if the server does
not support the named extension, or if no module to interface with it exists.
.SS "init_extensions"
.IX Subsection "init_extensions"
.Vb 1
\&  $x\->init_extensions;
.Ve
.PP
Initialize protocol extensions. This does a ListExtensions request, then calls
\&\fBinit_extension()\fR for each extension that the server supports.
.SH "WRITING EXTENSIONS"
.IX Header "WRITING EXTENSIONS"
Internally, the X11::Protocol module is table driven. All an extension has to
do is to add new add entries to the protocol object's tables. An extension
module should \f(CW\*(C`use X11::Protocol\*(C'\fR, and should define an \fBnew()\fR method
.PP
.Vb 2
\&  X11::Protocol::Ext::NAME
\&    \->new($x, $request_num, $event_num, $error_num)
.Ve
.PP
where \f(CW$x\fR is the protocol object and \f(CW$request_num\fR, \f(CW$event_num\fR and \f(CW$error_num\fR
are the values returned by \fBQueryExtension()\fR.
.PP
The \fBnew()\fR method should add new types of constant like
.PP
.Vb 1
\&  $x\->{\*(Aqext_const\*(Aq}{\*(AqConstantType\*(Aq} = [\*(AqConstant\*(Aq, \*(AqConstant\*(Aq, ...]
.Ve
.PP
and set up the corresponding name to number translation hashes like
.PP
.Vb 2
\&  $x\->{\*(Aqext_const_num\*(Aq}{\*(AqConstantType\*(Aq} =
\&    {make_num_hash($x\->{\*(Aqext_const\*(Aq}{\*(AqConstantType\*(Aq})}
.Ve
.PP
Event names go in
.PP
.Vb 1
\&  $x\->{\*(Aqext_const\*(Aq}{\*(AqEvents\*(Aq}[$event_number]
.Ve
.PP
while specifications for event contents go in
.PP
.Vb 1
\&  $x\->{\*(Aqext_event\*(Aq}[$event_number]
.Ve
.PP
each element of which is either \f(CW\*(C`[\e&unpack_sub, \e&pack_sub]\*(C'\fR or
\&\f(CW\*(C`[$pack_format, $field, $field, ...]\*(C'\fR, where each \f(CW$field\fR is \f(CW\*(Aqname\*(Aq\fR,
\&\f(CW\*(C`[\*(Aqname\*(Aq, \*(Aqconst_type\*(Aq]\*(C'\fR, or \f(CW\*(C`[\*(Aqname\*(Aq, [\*(Aqspecial_name_for_zero\*(Aq,
\&\*(Aqspecial_name_for_one\*(Aq]]\*(C'\fR, where \f(CW\*(Aqspecial_name_for_one\*(Aq\fR is optional.
.PP
Finally,
.PP
.Vb 1
\&  $x\->{\*(Aqext_request\*(Aq}{$major_request_number}
.Ve
.PP
should be an array of arrays, with each array either \f(CW\*(C`[$name, \e&packit]\*(C'\fR or
\&\f(CW\*(C`[$name, \e&packit, \e&unpackit]\*(C'\fR, and
.PP
.Vb 1
\&  $x\->{\*(Aqext_request_num\*(Aq}{$request_name}
.Ve
.PP
should be initialized with \f(CW\*(C`[$minor_num, $major_num]\*(C'\fR for each request the
extension defines. For examples of code that does all of this, look at
X11::Protocol::Ext::SHAPE.
.PP
X11::Protocol exports several functions that might be useful in extensions
(note that these are \fInot\fR methods).
.SS "padding"
.IX Subsection "padding"
.Vb 1
\&  $p = padding $x;
.Ve
.PP
Given an integer, compute the number need to round it up to a multiple of 4.
For instance, \f(CWpadding(5)\fR is 3.
.SS "pad"
.IX Subsection "pad"
.Vb 1
\&  $p = pad $str;
.Ve
.PP
Given a string, return the number of extra bytes needed to make a multiple
of 4. Equivalent to \f(CW\*(C`padding(length($str))\*(C'\fR.
.SS "padded"
.IX Subsection "padded"
.Vb 1
\&  $data = pack(padded($str), $str);
.Ve
.PP
Return a format string, suitable for \fBpack()\fR, for a string padded to a multiple
of 4 bytes. For instance, \f(CW\*(C`pack(padded(\*(AqHello\*(Aq), \*(AqHello\*(Aq)\*(C'\fR gives
\&\f(CW"Hello\e0\e0\e0"\fR.
.SS "hexi"
.IX Subsection "hexi"
.Vb 1
\&  $str = hexi $n;
.Ve
.PP
Format a number in hexidecimal, and add a \*(L"0x\*(R" to the front.
.SS "make_num_hash"
.IX Subsection "make_num_hash"
.Vb 1
\&  %hash = make_num_hash([\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq]);
.Ve
.PP
Given a reference to a list of strings, return a hash mapping the strings onto
numbers representing their position in the list, as used by
\&\f(CW\*(C`$x\->{\*(Aqext_const_num\*(Aq}\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
This module is too big (~2500 lines), too slow (10 sec to load on a slow
machine), too inefficient (request args are copied several times), and takes
up too much memory (3000K for basicwin).
.PP
If you have more than 65535 replies outstanding at once, sequence numbers
can collide.
.PP
The protocol is too complex.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant <SMCCAM@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1),
X(1), 
X11::Keysyms, 
X11::Protocol::Ext::SHAPE,
X11::Protocol::Ext::BIG_REQUESTS,
X11::Protocol::Ext::XC_MISC,
X11::Protocol::Ext::DPMS,
X11::Protocol::Ext::XFree86_Misc,
X11::Auth,
\&\fIX Window System Protocol (X Version 11)\fR,
\&\fIInter-Client Communications Conventions Manual\fR,
\&\fIX Logical Font Description Conventions\fR.
