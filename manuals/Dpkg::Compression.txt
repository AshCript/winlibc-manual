.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Compression 3perl"
.TH Dpkg::Compression 3perl "2023-05-11" "1.21.22" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Compression \- simple database of available compression methods
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This modules provides a few public functions and a public regex to
interact with the set of supported compression methods.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "@list = \fBcompression_get_list()\fR" 4
.el .IP "\f(CW@list\fR = \fBcompression_get_list()\fR" 4
.IX Item "@list = compression_get_list()"
Returns a list of supported compression methods (sorted alphabetically).
.IP "compression_is_supported($comp)" 4
.IX Item "compression_is_supported($comp)"
Returns a boolean indicating whether the give compression method is
known and supported.
.ie n .IP "compression_get_property($comp, $property)" 4
.el .IP "compression_get_property($comp, \f(CW$property\fR)" 4
.IX Item "compression_get_property($comp, $property)"
Returns the requested property of the compression method. Returns undef if
either the property or the compression method doesn't exist. Valid
properties currently include \*(L"file_ext\*(R" for the file extension,
\&\*(L"default_level\*(R" for the default compression level,
\&\*(L"comp_prog\*(R" for the name of the compression program and \*(L"decomp_prog\*(R" for
the name of the decompression program.
.Sp
This function is deprecated, please switch to one of the new specialized
getters instead.
.IP "compression_guess_from_filename($filename)" 4
.IX Item "compression_guess_from_filename($filename)"
Returns the compression method that is likely used on the indicated
filename based on its file extension.
.ie n .IP "$regex = \fBcompression_get_file_extension_regex()\fR" 4
.el .IP "\f(CW$regex\fR = \fBcompression_get_file_extension_regex()\fR" 4
.IX Item "$regex = compression_get_file_extension_regex()"
Returns a regex that matches a file extension of a file compressed with
one of the supported compression methods.
.ie n .IP "$ext = compression_get_file_extension($comp)" 4
.el .IP "\f(CW$ext\fR = compression_get_file_extension($comp)" 4
.IX Item "$ext = compression_get_file_extension($comp)"
Return the file extension for the compressor \f(CW$comp\fR.
.ie n .IP "$comp = \fBcompression_get_default()\fR" 4
.el .IP "\f(CW$comp\fR = \fBcompression_get_default()\fR" 4
.IX Item "$comp = compression_get_default()"
Return the default compression method. It is \*(L"xz\*(R" unless
\&\f(CW\*(C`compression_set_default\*(C'\fR has been used to change it.
.IP "compression_set_default($comp)" 4
.IX Item "compression_set_default($comp)"
Change the default compression method. Errors out if the
given compression method is not supported.
.ie n .IP "$level = \fBcompression_get_default_level()\fR" 4
.el .IP "\f(CW$level\fR = \fBcompression_get_default_level()\fR" 4
.IX Item "$level = compression_get_default_level()"
Return the global default compression level used when compressing data if
it has been set, otherwise the default level for the default compressor.
.Sp
It's \*(L"9\*(R" for \*(L"gzip\*(R" and \*(L"bzip2\*(R", \*(L"6\*(R" for \*(L"xz\*(R" and \*(L"lzma\*(R", unless
\&\f(CW\*(C`compression_set_default_level\*(C'\fR has been used to change it.
.IP "compression_set_default_level($level)" 4
.IX Item "compression_set_default_level($level)"
Change the global default compression level. Passing undef as the level will
reset it to the global default compressor specific default, otherwise errors
out if the level is not valid (see \f(CW\*(C`compression_is_valid_level\*(C'\fR).
.ie n .IP "$level = compression_get_level($comp)" 4
.el .IP "\f(CW$level\fR = compression_get_level($comp)" 4
.IX Item "$level = compression_get_level($comp)"
Return the compression level used when compressing data with a specific
compressor. The value returned is the specific compression level if it has
been set, otherwise the global default compression level if it has been set,
falling back to the specific default compression level.
.ie n .IP "compression_set_level($comp, $level)" 4
.el .IP "compression_set_level($comp, \f(CW$level\fR)" 4
.IX Item "compression_set_level($comp, $level)"
Change the compression level for a specific compressor. Passing undef as
the level will reset it to the specific default compressor level, otherwise
errors out if the level is not valid (see \f(CW\*(C`compression_is_valid_level\*(C'\fR).
.IP "compression_is_valid_level($level)" 4
.IX Item "compression_is_valid_level($level)"
Returns a boolean indicating whether \f(CW$level\fR is a valid compression level
(it must be either a number between 1 and 9 or \*(L"fast\*(R" or \*(L"best\*(R")
.ie n .IP "$threads = \fBcompression_get_threads()\fR" 4
.el .IP "\f(CW$threads\fR = \fBcompression_get_threads()\fR" 4
.IX Item "$threads = compression_get_threads()"
Return the number of threads to use for compression and decompression.
.IP "compression_set_threads($threads)" 4
.IX Item "compression_set_threads($threads)"
Change the threads to use for compression and decompression. Passing \f(CW\*(C`undef\*(C'\fR
or \fB0\fR requests to use automatic mode, based on the current \s-1CPU\s0 cores on
the system.
.ie n .IP "@exec = compression_get_cmdline_compress($comp)" 4
.el .IP "\f(CW@exec\fR = compression_get_cmdline_compress($comp)" 4
.IX Item "@exec = compression_get_cmdline_compress($comp)"
Returns a list ready to be passed to \f(CW\*(C`exec\*(C'\fR, its first element is the
program name for compression and the following elements are parameters
for the program.
.Sp
When executed the program will act as a filter between its standard input
and its standard output.
.ie n .IP "@exec = compression_get_cmdline_decompress($comp)" 4
.el .IP "\f(CW@exec\fR = compression_get_cmdline_decompress($comp)" 4
.IX Item "@exec = compression_get_cmdline_decompress($comp)"
Returns a list ready to be passed to \f(CW\*(C`exec\*(C'\fR, its first element is the
program name for decompression and the following elements are parameters
for the program.
.Sp
When executed the program will act as a filter between its standard input
and its standard output.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 2.01 (dpkg 1.21.14)"
.IX Subsection "Version 2.01 (dpkg 1.21.14)"
New functions: \fBcompression_get_file_extension()\fR, \fBcompression_get_level()\fR,
\&\fBcompression_set_level()\fR, \fBcompression_get_cmdline_compress()\fR,
\&\fBcompression_get_cmdline_decompress()\fR, \fBcompression_get_threads()\fR and
\&\fBcompression_set_threads()\fR.
.PP
Deprecated functions: \fBcompression_get_property()\fR.
.SS "Version 2.00 (dpkg 1.20.0)"
.IX Subsection "Version 2.00 (dpkg 1.20.0)"
Hide variables: \f(CW$default_compression\fR, \f(CW$default_compression_level\fR
and \f(CW$compression_re_file_ext\fR.
.SS "Version 1.02 (dpkg 1.17.2)"
.IX Subsection "Version 1.02 (dpkg 1.17.2)"
New function: \fBcompression_get_file_extension_regex()\fR
.PP
Deprecated variables: \f(CW$default_compression\fR, \f(CW$default_compression_level\fR
and \f(CW$compression_re_file_ext\fR
.SS "Version 1.01 (dpkg 1.16.1)"
.IX Subsection "Version 1.01 (dpkg 1.16.1)"
Default compression level is not global any more, it is per compressor type.
.SS "Version 1.00 (dpkg 1.15.6)"
.IX Subsection "Version 1.00 (dpkg 1.15.6)"
Mark the module as public.
